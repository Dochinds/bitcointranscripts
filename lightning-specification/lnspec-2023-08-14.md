---
title: Lightning Specification Meeting
transcript_by: carlaKC via TBTBTC v1.0.0
tags: ['lightning']
date: 2023-08-14
---

Speaker 0: 00:00:00

I'm pressing your keyboard from the recording from Skype.

Speaker 1: 00:00:05

So is everyone gonna mute while you type now?

Speaker 0: 00:00:08

Yeah, gotta mute while you type now, guys.

Speaker 1: 00:00:11

Well, I guess they also have all the training data of our past recordings as well, so.

Speaker 0: 00:00:17

That's true. All your passwords belong to everyone.

Speaker 2: 00:00:25

Just need burner keyboards, right?

Speaker 3: 00:00:29

My typing is so bad, you'll only get

Speaker 0: 00:00:31

30%.

Speaker 4: 00:00:33

I don't know what apps, they have on-screen keyboards where they randomize the location of the buttons after each key press.

Speaker 1: 00:00:41

You remember that old Mac keyboard, the one that had the really bad vertical distance? Maybe that's like a better-

Speaker 4: 00:00:47

The butterfly keyboard, yeah.

Speaker 1: 00:00:48

Yeah, the butterfly, yeah. Everyone goes on butterfly.

Speaker 4: 00:00:52

My personal Mac still has it.

Speaker 1: 00:00:59

I'm gonna rejoin because I messed up my thing. Yeah, like on highlights of mine when I click it accidentally.

Speaker 5: 00:01:17

All right, should we start? I want to talk a quick update on dual funding because I've been working with Lisa on cross-compatibility tests between CoreLightning and Eclair, and so far everything looks good. The only part that has not been yet fully implemented in CLN is the reconnection part when you disconnect in the middle of the signature exchange and this kind of reconnection is supposed to complete that signature exchange with new TLV, one new TLV added to channel re-establish. So I'm just waiting for Lisa to finalize that, then I'll be able to do cross-combat test on those two. And once both are compatible, I guess we're gonna probably rework the commits and rebase the PR on top of master, but then it should be ready to go. And that will also free up some cleanup on the quiescence and splicing spec PRs so that we can have a same basis to work on those.

Speaker 3: 00:02:17

Cool.

Speaker 1: 00:02:21

Cool, yeah, we're trying to look at some of the questions and splicing stuff and there's like, it was kind of a stock on top of each other. So decoupling it would definitely make it easier to like work through and understand.

Speaker 3: 00:02:35

Yeah, Dusty's in here. So on kind of a, I actually don't know. Is it further up? There's splicing further up. No, anyway. So we've shipped an experimental splicing. So people are busy breaking it all over the place right now. So there's this, it's experimental. So they get to keep both pieces when they break it, but yeah. It turns out, yeah. One way to test is to do testing in CI. The other way is to just throw it at users, apparently.

Speaker 1: 00:03:04

Oh, yeah, they'll do all the random shit that you need, basically. No, I know.

Speaker 3: 00:03:10

A little bit more testing would be nice. But, you know, hey, they really wanted to make it into this release. So it's labeled experimental, and people can turn it on and keep both pieces. It works in the happy case, it's just all the unhappy cases where people are discovering that you know, force closes and things. So, but you know, Hopefully that will resolve in the next three days before I do the final release. Sure.

Speaker 1: 00:03:35

Cool. Is there any stuff that should start to come back to this book? I know like T-Bass had that gist of like other edge casey stuff. And I'm guessing now the idea to like, you know, sort of compile that down into a new text eventually in terms of like what actually works a lot or what needs to be changed or whatever.

Speaker 5: 00:03:51

Oh yeah I haven't worked on that at all but yeah at some point we were discussing how to represent message exchanges so that we could have test vectors that would be exactly the messages exchanged. It could also be an input for the test at some point, but it's also useful to have something visual, where people can see exactly what messages are exchanged and why this scenario is not working, so that people implementing the feature understand some of the edge cases and details that can happen when some of these messages are out of order or something like that. But I haven't worked on it more, I think, yeah. I won't have time to work on that in the very short term, but that's definitely something I'll come back to. Cool.

Speaker 1: 00:04:39

Yeah, and then the other related things, we started to like take a look at the dynamic commitment stuff again, and kind of like what we talked about in IC around kind of like, you know, aligning it with at least with the message prefix and making sure the message flow meshes as much as possible. That's something we're doing in the background. I haven't started any code or anything, just refreshing our mental model of the actual PRs, given some nuances if you looked at it last. But I think we'll have anything that comes through either on the questions or the slicing things. I think we also want the STFU for this as well, because otherwise it's hard to do upgrades. I mean, it's simpler if there's no HDLCs. Obviously, you can upgrade HDLCs, but it's a lot simpler not to.

Speaker 3: 00:05:20

Yeah.

Speaker 5: 00:05:24

Yeah, great. So I think in the end, it's just gonna end up being adding more PLVs to these place messages so that it does to just explain what we want to negotiate on top of just creating a new transaction. I think it should be simple enough, but

Speaker 0: 00:05:40

it's going

Speaker 5: 00:05:40

to be to talk about it and to retell it once we have a standard basis for the PR after dual funding is merged. Cool.

Speaker 1: 00:05:52

And the TLBs are mainly for re-establishers, right? So basically, you remember what happened on reconnection type of a thing? For splicing,

Speaker 5: 00:06:00

you mean? I mean also in splicing it for dynamic commitment upgrades, I guess.

Speaker 1: 00:06:05

Ah, yes.

Speaker 5: 00:06:06

Like saying, oh, by the way, I want to do that and that and update those fields and those fields, something like that.

Speaker 1: 00:06:12

Yeah, exactly. And it does look similar, or there's a bunch of stuff in channel established now to basically let you pick

Speaker 6: 00:06:16

up but yeah that's the thing

Speaker 1: 00:06:17

we need to sort of like you know merge if possible.

Speaker 5: 00:06:23

Oh yeah I see I see what you mean you mean it could be either directly when you reconnect but if you don't you don't actually have to reconnect you could do it while staying connected so the same TLVs that will be added to channel reestablish will also be added to splicing it I guess.

Speaker 1: 00:06:38

Oh that's right there's a splicing message yeah I'm still a little behind on that stuff but

Speaker 3: 00:06:45

I did

Speaker 1: 00:06:45

a pretty good core type work step so now I can start to catch up with the rest of the world.

Speaker 5: 00:06:55

All right, so I guess that's it for dual funding, pricing, and all those related stuff. So there's that PR by Guincenzo about clarifying optional and mandatory feature bits. I think it's now small enough and good enough. It's just, let's just, I can merge. You can have a look at it. It's only four lines, I guess now.

Speaker 7: 00:07:16

Yeah, I didn't change something that we all already did, right? So we should, It's just a clarification

Speaker 3: 00:07:33

in the spec.

Speaker 1: 00:07:35

Yeah. I know you had a question around the wording, Keegan. Did that ever get resolved in line, if you're wrong?

Speaker 0: 00:07:41

Yeah, I believe I went over it out of band. Sorry, I did not put it back on the review.

Speaker 1: 00:07:48

No problem. OK, cool. OK, should we land that here, if people like it?

Speaker 7: 00:07:59

I think maybe we are here. We can discuss the wording. The suggestion was to change from must, not set all the film mandatory, optional and mandatory to shoot. But I don't see the point.

Speaker 1: 00:08:23

Is the rationale that like, it doesn't say what you should do if they said it or? Because must, I think they're saying that must should be, must is like, you're gonna bail out. While should is, they shouldn't do it, but also you shouldn't care. Or, you know, I think that was like the describing dumb

Speaker 3: 00:08:43

shit is pretty obvious. I don't know. I mean, I'm happy with a must like don't don't do this. And what are you doing? Like, seriously? It's weird. We never specified it. Like it was said to do this or do this. We never said you could do that. If people do it, I'm not sure how people respond. But I know I find it hard to care about these cases. It's like, well, if someone says both options, then they're just confused. And if you go to weird stuff, I know, it's not a bad thing to specify, like don't set both. Just don't, like we haven't defined that. You don't know what people will do. Don't do it. I think, I mean, most implementations will go, test, you know, do I have mandatory, like, you know, is this required? Yes. And they'll behave appropriately. I think our code, we don't explicitly reject you if you set both, but we will treat it as mandatory. We basically go, if we understand it, we go, is either one set, we don't care. I think everyone will actually behave how this behaves. Yeah,

Speaker 7: 00:09:45

I think we'll do that. I just would tell him that that's his thing. He takes the mandatory one. I guess LDK reject if we specify the optional one. No, LDK do the same thing, I guess.

Speaker 1: 00:10:06

Yeah, I think we're not doing behavior. Like the only time we reject is if you have a required that we don't know about at all. So there's no constant or whatever, right? And that's just the kind of like, I don't know what you're gonna do. I don't know what you want. I'm gonna bail out, which makes sense. There's one related thing that I ran into, basically, like last mile tapword stuff, like in terms of on-chain stuff, is that, I think this came up a few times around the implicit versus explicit negotiations, so it's the implicit being, when we say a BLAS negotiated for a channel type, for example, if we have anchor bit open, we'll open that by default right now. The explicit meaning actually specifying the channel type feature bit in open channel. But what I realized, which is something that isn't new in the process is that I think post taproot, I don't really think you can always use the implicit negotiation. For example, right now we have a test case where both sides have the taproot feature bit set. But we actually want to open an anchor type. So I guess it's more so about how people handle that default behavior. Because at least right now, in the LND code, you can't open it for a publish channel. Let's say you both have the feature bit set and you need to open channel CLI with no arguments. It'll try to open a taproot channel, but then fail because it has to be private channel only. But then at that point, the only way you can override that behavior which would be for people just to start setting saying, I want an anchor feature bit. I added the implicit negotiation for an I-test, I think I'm going to remove it generally, meaning then anchors will be the default. But just stating that once we have multiple channel types, it's no longer really clear what the default is or what the implicit is. So at a certain point, it may make sense for us to like flip the channel type bit to required and say everything must be implicit from now on. Because otherwise the negotiated is somewhat ambiguous at times, particularly what you want versus what they intend.

Speaker 3: 00:11:49

Yeah, no, absolutely. The whole implicit was like kind of a backwards compatibility hack for older nodes. And at this point, we shouldn't be adding to that. We should just be going, no, no, no. These days, say what you want, right? Because it's so much nicer to go, yeah, here's the channel type I want. And it's really explicit. So yeah, I wouldn't, I would suggest, yeah, you're right, we don't expand the implicit logic, but that kind of gets abandoned slowly, and maxes out at like anchor. And then from now on, everyone should just be saying exactly what channel type and eventually you're right we make it mandatory and that logic goes away and everyone's happy and unicorns dancing.

Speaker 0: 00:12:22

LDK is already making it like half mandatory if we we calculate the implicit based on the feature bids but then if we if the implicit that we calculate is anything aside from only static remote key, we just failed to open the channel. We say like, what are you doing? You should have negotiated a...

Speaker 1: 00:12:39

An actual explicit one. Yeah, we have something similar. We had a bug we fixed there too, But like, yeah, we have a thing too, where like we try to assert if it should have been explicit and maybe it's about like avoiding the whole downgrade type of a thing basically, of like going to static key. But I guess we can maybe remove or whatever, whatever we call it, non-static key. Remove that one, non-to-explicit. There's a bunch of names for it.

Speaker 3: 00:13:06

Yeah, so that PR that says, basically, we should assume these things and make these other ones compulsory and whatever else, I think we decided last meeting we'll do a mid-step where we basically just turn all these things on as compulsory and I think static remote key was definitely one of them right so I don't think anchors was yet but yeah I was so we're about to have a release but then next release I'm planning on turning those on and see what happens so and see what happens.

Speaker 1: 00:13:31

So, cool. Yeah, we can do that for 18. We're also on the cusp of getting to release as well.

Speaker 3: 00:13:36

That'd be cool.

Speaker 1: 00:13:37

Not yet in the RC phase, but hopefully this week, finger crossed.

Speaker 5: 00:13:49

Cool.

Speaker 1: 00:13:53

Okay. Next thing. Cool. Okay. Next thing. Oh, so should we merge

Speaker 0: 00:14:02

1095?

Speaker 5: 00:14:04

Yep, go for it.

Speaker 1: 00:14:05

OK. All right, I just merged it. OK, close.

Speaker 5: 00:14:21

Yes, I think the main discussion that maybe got out of hand a bit is what to do with a case that just never happens where we both don't have an output. So do we just say you always have an output for the one who has the most, the biggest amount in the channel? And if both have exactly the same amount, it has to be sorted by pubkey or something like that?

Speaker 3: 00:14:47

Pubkey. Sure. Whatever is easiest to implement.

Speaker 1: 00:14:56

And so the idea here is that like, we're just saying that, well, the possibility of both of us not having output just can't exist anymore, right? So now, which is I guess, how is this different from what we have today? It's more like if we have the desk trimming, then it seems like it's the same.

Speaker 3: 00:15:14

Yeah. Basically, I think the closer today has to have an output, the other side can abandon their output. I think that's how it works today. Except there's a dust rule as well. Yeah, you can't both drop your outputs at the moment anyway.

Speaker 5: 00:15:37

But since there's no way to place out yet and everyone has a limit on the minimum size of a channel, we just, in practice, cannot be in that scenario. But yeah, we should make sure that it is covered and we avoid getting into that state by having the specification say, okay, it doesn't always gonna be at least one output.

Speaker 3: 00:15:58

Yeah.

Speaker 5: 00:16:06

Apart from that, the only functional change is that if you send multiple shutdown, you can update the script you are shutting down to, except if you're using a front shutdown script, which is something that people will have to implement. That's probably not implemented today, but apart from that, at least on my side, everything looks good until we start implementing it.

Speaker 1: 00:16:29

Yeah, so That was on my list to take a look at a sort of independent kind of POC implementation of it, just to see how things line up. The one thing I need to get back into the type of PR still is that now it does flag everything as RBF. So the idea is that, okay, well, you already flagged, everything's already RBF, then in the future, if that feature is there, you can just use that new protocol. And then eventually we can make that mandatory. So I think it should line up pretty well there. Yeah, I need to do another pass generally and then start to sign up like an actual implementation.

Speaker 3: 00:17:02

Cool, there's I think one thing that needs to be tweaked and that is that we do need the dust limit unfortunately in there you can't offer if your thing is definitively dust, according to relay rules. You cannot propose that output, because otherwise you will end up saying it can't relay on the other side. So I think that's the only, we do have to have the dust rules in there. We could either, We could simplify them and say it always has to be 524, whatever, or we could do the proper ones, which is 330 for witness and 524 for whatever else. But yeah, that was one addition I realized that, because otherwise you will end up with something you can't relay. So we do have to code that in.

Speaker 2: 00:17:48

And I don't care about

Speaker 6: 00:17:48

the case- And

Speaker 1: 00:17:48

to do we make the dust limit explicit

Speaker 3: 00:17:51

or just- Yeah, you can include your output if it's below dust limit. Otherwise I can end up with a, you know, Otherwise I can end up with a transaction that doesn't relay. And that's not supposed to happen.

Speaker 5: 00:18:08

So regarding the dust limit more generally, now that we have anchors with zero fee HTLC transaction, which means that we don't have the trimming threshold that adds to... Yeah, I mean, without the European core, it's the dust limit plus the fee you're paying for the HTLC transaction that decides whether or not you include the output in the commitment transaction. With Uncar output 0 fees, that's not the case. It's only the static dust limit, which means your commitment transaction becomes bigger, much quicker than before Uncar output 0 fees. So I was thinking of raising potentially the dust limit on nodes once we all support encode with zero feed, for example, set it to 2000 sets because anything below 2000 sets, you probably don't want to have an unchained output for it. What do you guys think about that?

Speaker 1: 00:19:02

You can't adjust it after the fact though, right? You're talking about like the open channel limit, but dynamic limits would let...

Speaker 5: 00:19:08

Yeah, I mean, in a world where we can dynamically update those things, Do you conceptually agree that it potentially would make sense to update that limit to something higher to avoid having a commitment transaction that's full of outputs that are 1000 SATs, for example?

Speaker 1: 00:19:29

I think so, right? In terms of looking at the chain fee level and updating it accordingly. And there's that whole thread that we discussed a few weeks back around, kind of like not always going to chain or going to chain and giving up, you know, things like that. Generally, there should be another, you know, toolkit there. And yeah, I definitely want to be able to update the summit stuff because I mean that was what we're going to do right

Speaker 5: 00:19:51

okay so yeah I think that means we really need to keep sections about checking thresholds with a dust limit in many cases such as for example this mutual close because if at some point we start having a just limit threshold of 5, 000 SATs on both sides of the channel, we still need to make sure that outputs are not below that in the mutual close as well.

Speaker 3: 00:20:17

The other, if you really want to do it dynamically, I mean, sending multiple signatures is like doing it on a per HTLC basis is possible, but then you really need the ability to reject HTLCs and go, No, no, I don't like that. I don't consider that to be dust. If you want that, we're going to have to put that on chain and things like that. Or vice versa, right? But that's a whole other can of worms. So yeah, increasing a static dust limit is probably easier.

Speaker 5: 00:20:49

Right. Or maybe, yeah, Or maybe once we have something like Simplified Commitments, every time you yield your turn or something like that, you announce your Dust Commit for the next turn. We can think of potentially many things once we start having simplified commitments or something different than what we have today.

Speaker 3: 00:21:07

Yeah well simplified commitments opens the door to failing things and so you can propose the HTLC and say I want this to be dust and I'll go no no that's not I'm going to reject it because that has to be on chain. And you can go, OK, well, I'm not prepared to do that. And we can just go our separate ways, right?

Speaker 5: 00:21:22

Yeah, even though it's still better if we negotiate it up front so that we avoid going back and forth and failing things that we actually want to relay.

Speaker 3: 00:21:32

Yeah.

Speaker 5: 00:21:33

I see what you mean.

Speaker 3: 00:21:36

Yeah, you end up with combinatorial explosion if you allow both possibilities of each one, though. But I get we have to think about that. But it would be kind of cool. I just fuck I hate fees.

Speaker 1: 00:21:49

No, fees are annoying part about Bitcoin, right? Like, Cool.

Speaker 6: 00:22:25

Next one. Like I'm not sure it's an updated yet.

Speaker 5: 00:22:40

Yeah, there are still a lot of needs on the PR, but apart from that and starting by just keeping implementations where everything is required. It's looking good to me.

Speaker 1: 00:22:53

Do we need to try to coordinate on that? I guess it's okay, right? Because it's not like we're adding a new thing that'll be required. We already have pretty good feature build overlap today. And then that's what would just be required. And I guess this is also the set of things that we know. Everyone has already

Speaker 6: 00:23:09

done it. So it shouldn't be an issue.

Speaker 5: 00:23:11

I think on the contrary, if we want to see things break, we definitely should not coordinate and should release on their own and see if things break. If you don't, hopefully.

Speaker 1: 00:23:22

I'll see you on test set. No, I'm not going to.

Speaker 5: 00:23:29

No, those features are features that we have all shipped for such a long time ago that only the people with whom it will break are people who are already potentially kind of sort out of the network.

Speaker 1: 00:23:41

So. Yeah, it's actually several years old. Cool. I just added, you know, required for seeing that. One of the path stuff, but like, oh yeah, I guess it's saying go from 32 to SCID. I guess, is this tangible? I'm guessing this makes the stuff easier to scan. I don't know if there are any benefit of the key versus the SCID. I guess the key decouples from SCID alias. You don't have to care about that. Maybe that's one thing, but I'm not sure if that bothers in terms of like hoppins or something like that.

Speaker 5: 00:24:17

The kernel ID is a long-term identifier, whereas short-channel IDs are potentially things that come and go as you close channels. At this point, the introduction point, because for intermediate nodes, we are already using those short-channel IDs inside the payment union to relay so we would have the same issue and it's just used to identify your peer. But for the introduction node maybe it's a bit more painful but yeah.

Speaker 3: 00:24:47

Yeah it basically depends on the expiry of the offer.

Speaker 0: 00:24:51

Right? It's equally painful. But like, if you're talking about offers, you know, the vast majority of offers, the vast majority of payments in general tend to be these like shorter term things that people like post that might be a side effect of both love and sucking and requiring that but

Speaker 8: 00:25:08

that will still be enough material number of

Speaker 0: 00:25:11

payments and for those this may be particularly useful because you can have a much smaller QR code but yeah I mean it is the case that if you want to build a very long term offer, you probably wouldn't use this. Still, this is just

Speaker 8: 00:25:27

an option, right? You can go still.

Speaker 1: 00:25:29

So, okay. So it's not mandatory. So it's just like adding a TLV to let you do the other works.

Speaker 5: 00:25:34

Yeah. Yeah. So basically the implementation could decide when you generate an offer with a long expiration, we would just wait for you and we've another ID and if you have a short expiration, we would use a SCID. Yeah. Potentially, yeah.

Speaker 6: 00:25:48

The house, there are guardians. You'll search for ID. That's what you

Speaker 5: 00:25:53

need to do.

Speaker 0: 00:25:54

I did not hear anything you just said.

Speaker 1: 00:25:56

Yeah, it's kind of muffled.

Speaker 6: 00:25:58

Can you hear me now?

Speaker 1: 00:25:59

Yeah, it's better.

Speaker 6: 00:26:01

Yeah, For the encrypted data hops, they already have a short channel ID TLB in there. So there wasn't nothing really added. It was just a change that you could actually set it. And then for the instruction node, you would write a type essentially that allows either.

Speaker 3: 00:26:18

So the hack where we do both is, I don't know. It has some appeal. So 02, 03 is a pubkey. O0, 01 is a short channel ID. It always bugged me that we had that extra byte. So we could abuse it that way as proposed. Now it would actually apply in a few different places. So I mean, I only proposed that 24 hours ago. So I don't know if people have really absorbed that.

Speaker 6: 00:26:51

The changes in the PR, so if you want to look at it, sorry, I like it.

Speaker 3: 00:26:55

OK, cool. It's weird because it's a new fundamental type because you've got to parse it like, you know, it's non-trivial to pull it out. But sure.

Speaker 5: 00:27:07

You know, it's interesting because it's extensible. That means it's going to be another idea that the binary is either 0 or 1 plus short channel ID, or 2 or 3 plus a 32 byte pubkey, or 4 or 5 plus something else in the future. So it's interesting.

Speaker 3: 00:27:27

Yeah. Adding another extension point sounds, it feels like a hack, but I don't know.

Speaker 9: 00:27:32

There are

Speaker 3: 00:27:32

a number of places where it's like short channel ID or pubkey. Sorry, Peter. Sorry, Matt.

Speaker 0: 00:27:37

Does anyone use open SSL to read pubkeys? Those are already defined. Oh God, I hope not. They are. No, no, there's a definition for like, one, two, three, four, and five or something.

Speaker 1: 00:27:52

Oh, yeah, there are prefixes. Yeah. And there's like, there's like hybrid also. Yeah.

Speaker 5: 00:27:56

Yeah, they're

Speaker 0: 00:27:57

really bad. Don't use them. But they exist. They're defined. Yep.

Speaker 1: 00:28:12

Is that a PR val? Yeah. Is that a PR about?

Speaker 9: 00:28:15

No, I'm just I'm working on a blinded payment path construction for LDK. And basically how our API works is, it takes a list of like the unblinded payloads that are going to go in the blinded path. And So those payloads can contain stuff like payment relay, fee parameters, and payment constraints. And then from those payloads, I construct the blinded pay info that's going to go in the offer. But the only field that I can't really construct from that is the HTLC maximum mset because that's not included in the blinded payment TLVs for the blinded path. So I'm just wondering if we plan to add that or if I should kind of Like how are people setting this and I don't know, T-Best, does that make sense?

Speaker 5: 00:29:08

On top of my head, no. I really, that's something where I really need to dive deep into the code actually to make sure. So can you just put that in writing somewhere so that we can look at it calmly tomorrow?

Speaker 1: 00:29:23

Yeah, I wrote down in the summary. But what I'm picking up is that like the HLC max value isn't in the blind path TLV payload, but it's something that like you need to know to construct a route to know if you can send a payment or do shorting, basically, right?

Speaker 9: 00:29:33

Yeah, to construct the offer. Because it's a field in the offer, but it's not a field in the original blended path payloads. Yeah. OK, cool. I will leave a comment somewhere or maybe propose something in PR.

Speaker 5: 00:29:54

Yeah, we need to look at the code again to make sure it makes sense.

Speaker 1: 00:30:17

Cool. Okay. Questions. I think this just bumped because we were looking at how this relates to splicing and stuff like that. So just trying to refresh it in our minds.

Speaker 5: 00:30:32

Yeah, I don't think there's anything new. We've been working on, I think we finished implementing a cohesence and master stuff, like one that we haven't tested cross compatibility with CNN yet. And we're finalizing the last bits of splicing before we do those compatibility tests. I don't think there's anything new in the PR at least.

Speaker 3: 00:30:56

The only interesting thing is that the feature bit changed. So we kind of decided, T-Best pinged me after we released RC1 with a really good idea that we shouldn't use the final feature bit until it's spec final. So we've added a hundred. So instead of like 160, instead of

Speaker 0: 00:31:13

63,

Speaker 3: 00:31:14

we're using 163 just as like a rough convention to go. And that way, if, if nothing changes in the respect final it and it gets a real feature bit, you can just advertise both in in, you know, in transition. But if something changes, you don't end up someone shipping the final one, and they're getting these weird interop errors, because oh, no, we're running our experimental version, whatever. So it's kind of a cute convention just to add 100 for, I think, you know, for things that are in progress, especially if you're deploying them, to add 100 so that we've got this, you're not going to break people who implement the final one, I wonder why the fuck nothing works. So we've just temporarily flipped to bit

Speaker 0: 00:31:53

163.

Speaker 3: 00:31:56

If people turn that on for a current release, and I think there's probably a good convention for anything like this, where the spec is not completely final, that just add

Speaker 0: 00:32:06

100.

Speaker 3: 00:32:09

Because we had this problem with dual fund where we broke it multiple times, and then if someone implemented final dual fund, they would get really confused because it would try to negotiate with old nodes.

Speaker 1: 00:32:17

Yeah. Yeah, yeah. Let me help.

Speaker 5: 00:32:22

Yeah, like staging. Yeah. We have a lot of bugs on our node. When we started activating the opening feature bit and having a lot of old CLN node connecting and saying that another feature bit was required, whereas it was not, and we would break the connection with a lot of old CRN nodes.

Speaker 3: 00:32:38

Yeah. Yes, so this should-

Speaker 6: 00:32:40

I don't

Speaker 5: 00:32:41

think it's a rule in the Bolt to always add 100, but just general implementation rule that when you start activating something experimentally in the network, don't use the final feature bit. You don't need to add anything to the bolt to mention that.

Speaker 3: 00:32:57

There's a contributing document that we should probably... It says how to write the bolts rather than the bolts themselves, and that probably should go in there.

Speaker 0: 00:33:04

100

Speaker 3: 00:33:04

is a good number. 100 plus is our free range of experimentals. And it's pretty easy to go look at 163 and know what that means. So it's a cute trick. So we should probably do that. It also means don't grab experimental features that happen to be a hundred plus an existing experimental feature. Cool.

Speaker 1: 00:33:39

So I say, we kind of talked about it earlier as far as like, you know, breaking stuff. Getting better. You're breaking stuff better

Speaker 5: 00:33:50

Slowly moving along nothing major to report We want one thing we discussed today with Richard is, it's not clear in the spec, but if you have a pending, yeah, if you have a pending splice that's not confirmed, do you allow another splice to be added as a child or do you force the other peer to RBF the pending splice if they want to make more contributions? I think it would make sense to always force RBFing when splices are unconfirmed because it's more efficient but suspect doesn't say anything about it and I don't know if the implementation does anything about that.

Speaker 3: 00:34:39

Yeah, no, because when one of the splices is confirmed, you assume it cancels all the others. So it's kind of implied they're at the same level. So they're all competing against each other. Otherwise you have to start introducing dependency trees and stuff and that's just messy.

Speaker 1: 00:34:53

Yeah, it's more challenging.

Speaker 5: 00:34:54

If you have a binning splice that's not confirmed and they send you splicing it, what are you gonna respond? Tx abort?

Speaker 3: 00:35:06

I would have to check the code but Do you know you can have multiple input you can you can propose multiple I believe

Speaker 5: 00:35:14

But it should it should use TX init RBF then, right? Because it's an RBF of the first one, it's more explicit to say TX init RBF instead of placing it again, right? Because for example, for zero-conf, then you don't really have a choice. And for zero-conf, you potentially must, yeah, you actually must chain those either instead of RBFing them. So that's why there's a distinction between a new splice init on top of an unconfirmed splice or TX init RBF for the splice. But for non-zero conf, I think we should always RBF.

Speaker 3: 00:35:56

Yes, I think so. But I may not have to check with Dusty as to what his interpretation is.

Speaker 6: 00:36:15

Cool.

Speaker 1: 00:36:19

Taproot. So I said I was going to have the spec thing draft by the next time. That happened, fortunately. But I have gained a lot more wisdom on on-chain stuff, generally. So I think a big thing I want to do is basically expand the on-chain section, which is basically HTLCs, breaches, et cetera. And the main thing that I was fixing in the past was just the additional data that needs to be stored or just regenerated. And so for everything you have the control box, but then also for all the replication paths you also need to store the top tweaks of the second and first level for HLCs. And that's because they can breed and then you have to basically use the top two to basically do the keyspend or they can go to

Speaker 6: 00:37:10

the second level as well. And that

Speaker 1: 00:37:12

was one thing that I hadn't stored, but then some eye tests basically showed just certain bugs there. But Yeah, so I've been on the on-chain stuff, I guess, for the past month or so. I think I finally concluded it last night as far as getting all the itests working, things like that. And this is the only thing that I think I had to do for, but I didn't follow up on just as far as storing that extra information. And I think technically for the second level of HTLCs, because it uses the same key, this is just the sweep after delay, I think you can just either regenerate it or only store one of them. But right now I store one for every single HTLC. So now all the HTLCs have these two levels alongside of it. Or sorry, these values, rather. But other than that, I think our implementation is more or less complete now in terms of all the on-chain stuff, all the breach stuff, some things with co-op close, re-establish, all that stuff. So now I'm going to start to work to get that wisdom back into the spec, and then ideally also add some basic test vectors around transaction construction, things like that as well.

Speaker 4: 00:38:15

Awesome. So one other thing that we were talking about last week of course was the fact that without the nonsense, Frost would be significantly simpler and I wanted to you know, follow up on that And one of the things that some of the cryptographers are saying is that the big issue with FrostNested inside Music too is that there still isn't a security proof. However, that isn't really the biggest blocker because significantly higher difficulty is going to be having some sort of threshold agreement for channel revocation because the revocation disclosure and the private disclosure that's significantly more complicated.

Speaker 0: 00:38:59

I'm confused by that. We already solved that. So We just have 10 revocation routes and we XOR them together. That's

Speaker 4: 00:39:06

already solved.

Speaker 1: 00:39:07

I'm not sure why we can't solve.

Speaker 6: 00:39:08

For some

Speaker 5: 00:39:08

definition of solved.

Speaker 10: 00:39:10

Well, I mean, it's like that's

Speaker 0: 00:39:12

the obvious solution. No one has anything better and that certainly works very well. Obviously works.

Speaker 4: 00:39:18

Were the 10 round trips, Matt? Sorry, is that what he said to you?

Speaker 0: 00:39:21

No, there's no 10 round trips. You just have 10 of the revocation hash tree things.

Speaker 1: 00:39:29

I think ARC means like in the wild if you actually had 10 signers, but I guess you would have some decomposition amongst the signers who has what value or something like that?

Speaker 6: 00:39:38

It'd be... Yeah,

Speaker 0: 00:39:39

you wouldn't need 10 individual round trips,

Speaker 10: 00:39:42

you would need 10 round trips, but they all run in parallel.

Speaker 0: 00:39:47

Or however many signers you have, of course.

Speaker 3: 00:39:50

Yeah, someone should actually write down the calculations showing the different simple combinations of how you break up the 10 into your 2 or 3 case, your whatever else. I mean, there's a number of ways of doing it.

Speaker 6: 00:40:01

Some of

Speaker 3: 00:40:01

them are obvious, some of them are not. I would like to see that.

Speaker 4: 00:40:06

I thought it was your proposal at the summit, unless I'm confusing it with the APA.

Speaker 3: 00:40:11

No, no, it was mine. I hated it, but Matt improved it And now I'm liking it more. It's dumb, and sometimes dumb things like, you know, nobody can fuck this up. Well, OK, so sorry. Of

Speaker 6: 00:40:24

course they can.

Speaker 3: 00:40:29

But you know, yeah.

Speaker 4: 00:40:31

OK, cool.

Speaker 3: 00:40:32

But the question was the number and I think Matt had some evidence that like to do three of five I think we need ten

Speaker 5: 00:40:38

or something.

Speaker 6: 00:40:41

Three

Speaker 0: 00:40:41

of five and four of five I think both need ten. And then if you want five of six or six of seven or anything like that, you need like 30 or so, you need like way more.

Speaker 5: 00:40:52

And suddenly it's kind of, yeah.

Speaker 3: 00:40:54

Yeah. Yeah, fuck those people. Okay.

Speaker 4: 00:40:56

What is, this is separate from the issue where you were saying that say a two of three consensus is not really achievable, but a three of four is, or was that for?

Speaker 0: 00:41:06

That is separate and that is still true.

Speaker 4: 00:41:10

Okay, so.

Speaker 1: 00:41:12

But were you gonna get into something around the Frost music two thing or something, or around the proof?

Speaker 6: 00:41:17

Yeah, I

Speaker 4: 00:41:17

was going to say that, you know, up until two minutes ago, my thinking was that with the bigger complication still being their vocation, which I guess isn't the case at least I want to see a write-up, which, you know, I'll do tomorrow with Matt. I was thinking that it doesn't really make sense to not do nonces because we have this more difficult barrier anyway. And so I was going to advocate that we proceed on course.

Speaker 0: 00:41:45

So that's, yeah, so I just pasted it on IRC, I guess I'll copy it on matrix and put it separate. But that's if you have 10 non-shares and you have five things and you split up the non-shares as indicated, then that gets you three or five.

Speaker 4: 00:42:02

Wait, wait, that's nonsense. I'm talking about revocation.

Speaker 6: 00:42:06

Sorry,

Speaker 0: 00:42:06

sorry, revocation, that's what

Speaker 4: 00:42:07

I meant.

Speaker 6: 00:42:07

Okay.

Speaker 0: 00:42:09

If you have 10 revocation shares and you split them up as follows, and then you XOR the result together, you get three or five out of that.

Speaker 1: 00:42:17

Cool. I think one interesting thing around like... Oh, go ahead.

Speaker 0: 00:42:22

I was going to say that we did like this. So last week, we'd kind of gotten very, not very far in the discussion. And then somebody said, like, hey, what about, have we asked the VLS folks? We did go ask the VLS folks. Sadly, I don't know if Ken's here, but DevRandom said this morning that he was having some technical issues and travel issues, so wasn't gonna be able to make it this week. But he did paste, well, I can leave it to you, Ken.

Speaker 1: 00:42:47

But he did

Speaker 0: 00:42:48

post on the spec meeting thing, saying basically like, the explicit script pack thing would be much simpler.

Speaker 2: 00:42:58

Right. What he said.

Speaker 4: 00:43:02

He also said it would probably be computationally cheaper on some low-powered devices. I think it's still comparatively negligible because at the end of the day, you

Speaker 1: 00:43:16

still have like number one, the difference in on-chain costs, which is more than double a witness size. And the other thing around, this is simpler, but have they done the frost stuff in the VLS setting as well? That's the main motivating factor we've been going in that direction. Should someone get that far before we double the force close cost for everybody to make potentially small use case in terms of no reviews are actually possible?

Speaker 2: 00:43:46

I think we should defer to DevRandom for the details there, but I don't think we're adamant about it. It's just that it seems simpler, is what he's saying.

Speaker 1: 00:43:59

Yeah, probably so. And at least where I've spent my time, I spent most of my time on the on-chain stuff. And maybe this is my recency bias of this is the last thing I worked on compared to this is the earlier thing. But at least our code base, which is updating assumptions of, okay, you need a control block, you need a tab tweak, this thing is slightly different, are you doing a key spend or a key, that was sort of like, we're kind of dominating a lot of our review cycle, but granted that I did do the non-suff a lot earlier on the process. This was kind of like, okay, like get into that stuff. But that's just like at least one data point at least where I happen to spend a significant time, but you know, somewhat skewed.

Speaker 4: 00:44:39

Yeah, we haven't really had any issues with the fronts, but with the noncess after we got over the initial hurdle of figuring out their nomenclature. If I dare say so, because it sounds like maybe we still haven't really gotten over it.

Speaker 1: 00:44:52

Yeah, I think everyone has names that work for them.

Speaker 4: 00:44:55

I still advocate for you can delete.

Speaker 2: 00:44:58

You can delete.

Speaker 0: 00:45:07

Yeah, I mean, I remain not sure where to go with this. The frost stuff seems, you know, doable enough. Is there there is an implementation somewhere if It's not just like a theory thing, not in the Lightning context, but there is outside of Lightning.

Speaker 1: 00:45:26

I think there are a few, I know like Lord Ferner has been working on stuff. They have some hard hardware wallet thingy. I think they're out there. I'm not sure if they're used quote-unquote seriously yet, beyond like a demo or something

Speaker 6: 00:45:38

like that.

Speaker 0: 00:45:39

So that doesn't seem that far away and it seems worth considering that. I think, yeah, I mean we do have to take a kind of holistic decision here of like, do we want Taproot to look like multisig for all counterparties? Or do we want Taproot to

Speaker 10: 00:45:59

look different for a multisig counterparty versus not?

Speaker 0: 00:46:03

And that would basically mean, I mean, at least as things exist as the crypto exists right now, I would, I would guess that means it has to be two of two multi-sig and it has to be this, let's call it 10

Speaker 8: 00:46:16

revocation secrets XORed together.

Speaker 0: 00:46:21

So, yeah, I mean, we have to decide. I think that's the decision. I think the decision is always looks like multisig or doesn't always look like multisig

Speaker 8: 00:46:34

and has a separate feature bit for multi-sig.

Speaker 4: 00:46:36

Matt, can you explain what your hesitation is? You said the crypto right now looks that you know there should be an explicit do of two multi-sig. That's not really the message that I've gotten from Jesse, but maybe I'm mixing

Speaker 6: 00:46:54

it up.

Speaker 0: 00:46:54

I mean, there's no proof. From what I've heard, there's not a lot of confidence in how to prove. It's not like there's no proof, there's no like approach for how to prove nested music or crossed in music yet. So I don't think we can make any kind of assumptions based on that yet.

Speaker 1: 00:47:17

Yeah, I think the interesting thing with that, or I kind of like our proof or not, is that like it is possible technically, right? And then so I think there's another question of like, yeah, like, it's

Speaker 0: 00:47:25

actually implemented and it works.

Speaker 1: 00:47:27

Yeah, yeah. So but but if it's possible, you know, get me, you know, Meaning that you can't even verify someone's doing it or not. There turned out to be an issue with the proof down the line. Doesn't that mess up the whole scheme, if you know what I mean? Or wouldn't issue in the nested instance mean that the non-nested instance, given that you can't distinguish the two, you know, if you don't have anything from the other party, you know, would that modify the security? It seems like a weird sort of like circular thing where it's like, you can do it, but we don't have a proof. But if let's say they can't write a proof or the proof show something, there's an issue there. Doesn't that like invalidate part of the actual greater scheme? Just like a way to think about it and I think that's where I'm wrangling with generally it's like okay you can do it you can't stop me from doing it but the fact that they can do it modify your security and all if the answer is no

Speaker 4: 00:48:14

that doesn't really seem to be the case because you know you're describing it from a third-party observer but you know the participants know more and one of the critical assumptions that you also don't think private key material to the participants and so if there's something where nonce nesting would reveal something to your other participants that not nesting it wouldn't, I think that that might potentially expose you to vulnerabilities where you at the very least would lose the threshold signature property even though externally it still looks perfectly sound.

Speaker 0: 00:48:49

Yeah, it seems to me like that would just imply that you can steal your counterparty's money, but not the other way around. Otherwise, presumably, MuSig2 itself would be not sound in some very material way. I think that's

Speaker 1: 00:49:00

where I'm getting at, right? That like, I send you a key, but that could be a nested instance. And I

Speaker 0: 00:49:05

guess- My point is we have to assume that no one serious will implement Frost nested inside of the muSIG too, or even muSIG nested in muSIG

Speaker 8: 00:49:17

until there's at least some level

Speaker 0: 00:49:18

of confidence that this is something that's secure. And so given that that is of unknown and potentially infinite timeline, Again, if we want to have multi-sig, we're going to have two of two in the script path, plus this 10 revocation secrets thing. Given that, do we just want to do that, or do

Speaker 8: 00:49:46

we want to have a separate feature bit for that?

Speaker 1: 00:49:50

I'm in the separate feature bit camp just because it feels like it's a theoretically important use case, but one that people just really don't seem to be ready to deploy anytime soon. And then on top of that, the burden of having to support that on the normal scheme and the burden there being double the witness size and the 10 nonce thing. However you may size that up, it's just sort of like things you're carrying around as baggage to support a case that maybe won't necessarily be super widespread. And I think there still is some value of uniformity there in terms of handling yourself, but then also just other cases, at least in the early days when it's only on advertised channels.

Speaker 4: 00:50:30

Then you're leaking though that you're likely trying to do a multi-sig setup.

Speaker 1: 00:50:36

Yeah, I don't know.

Speaker 6: 00:50:38

Unless other users call. In theory I

Speaker 1: 00:50:39

can deduce that, maybe just from your latency or something. I don't know. Right? But the thing is, the whole point of this initially was not leaking it. Right? That you, okay, well I could be five nodes and you don't really, you don't really know. Right. But

Speaker 4: 00:50:51

yeah. And of course, you know, with the unilateral close, you're still leaking the fact that it was one.

Speaker 0: 00:50:58

I think the other question on the VLS side, is there any ignoring the multi-sig case? And I guess it would be nice if they ran away here, ignoring the multi-sig case, is there any strong desire to avoid the nonce stuff just because of the storage requirement? Or I guess it's, you already have all the storage requirement and lightning so it doesn't matter.

Speaker 1: 00:51:19

And the other thing as well like as I mentioned earlier you have more storage requirements you basically need to store the control blocks unless you recreate them and also the tap tweaks which is the root hash you know the replication path. So even without the nonce which you know we're saying maybe you can avoid that with a deterministic approach, you still do have extra requirements in order to spend unless you recompute everything from scratch. And then either way, you need that additional stuff. Maybe there already are. I don't know.

Speaker 2: 00:51:43

I don't think it changes our storage requirements massively. So significantly. Massively, so significantly.

Speaker 0: 00:51:54

Any opinions from Ashton or Rusty?

Speaker 3: 00:52:02

No, I'm staying out for brighter people to decide what we should do and then I'm going to follow.

Speaker 5: 00:52:09

Same.

Speaker 1: 00:52:12

All right, our Arclight likes nonsense. I like nonsense.

Speaker 4: 00:52:19

No nonsense nonsense.

Speaker 10: 00:52:24

All right, I mean, this seems fine to me. You know, I think it does mean that we're going to end

Speaker 0: 00:52:30

up with a taproot-multisig-feature flag that will have different on-chain format and different everything and presumably that means everyone needs to support

Speaker 5: 00:52:42

both because

Speaker 0: 00:52:45

people are going to want to run it.

Speaker 6: 00:52:47

I think we have a bit

Speaker 4: 00:52:47

of incomplete information right now, Matt. And based on the majority of... I mean, I really agree with Lalu's reasoning here. The majority of the use case with the lack of Frost implementations seems like the best thing for the ecosystem at the moment is probably just

Speaker 0: 00:53:05

to go with the process. People will eventually support frost obviously like frost is a straightforward-ish thing to build and people will use that for lightning nodes I think that's clear.

Speaker 4: 00:53:16

People eventually will also support l2.

Speaker 0: 00:53:20

Well, I mean, that has a much more indeterminate timeline in terms of softworks. But the point being you're like, everyone will have to support both. Because someone some people will want to run very large multi-sig nodes. There'll be some big nodes on the network that are multi-sig and everyone's going to need to implement both the nonce version and the non-nonce version

Speaker 8: 00:53:42

in order to have broad compatibility.

Speaker 3: 00:53:45

No, what we do is we use LND as a forcing function. If you want to talk to LND, you've got to write a nested music proof.

Speaker 1: 00:53:55

If you do that, you'll get a job from one of us. Oh yeah, we'd be

Speaker 0: 00:54:01

happy to pay for that.

Speaker 1: 00:54:03

One question related to something Rusty brought up around the plus 100 as a convention for like pending stuff, right? So for example, ideally by this week we'll have merged something in and that something will be available with a build tag or a flag or whatever else, it feels like it makes sense that we should advertise the plus 100 feature bit for this. I don't know exactly what bit we have in the spec, but that just seems to be the thing to do going forward now, and we can do that pretty easily on our end.

Speaker 5: 00:54:31

Yeah.

Speaker 1: 00:54:32

Cool. Okay, we'll do that. Because we have something but you know, will it be the final thing? We need to interrupt to know exactly. Cool. I'll write that up.

Speaker 0: 00:54:44

Okay, Just to be clear, all of y'all will implement the non-nonce version eventually when people have demand for it?

Speaker 1: 00:54:54

Yeah, yeah. Whenever it's written out, whatever. Which might be three years, I don't know. Yeah, right. And then that'll just be the other channel type or whatever. And then at least with that, the latter half stays the same, assuming everything else.

Speaker 5: 00:55:12

Cool.

Speaker 4: 00:55:23

What's next CLTVX Fiery?

Speaker 1: 00:55:26

Yeah, I don't think there's any updates on Gossip yet. I need to sync up with Elle on that and she's not here yet either. So check that.

Speaker 3: 00:55:33

Yeah. Oh, so on the Gossip 2.0, like the extension that I promised Matt, I have a trick for short channel IDs. So the thing is that if you stop proving your UTXOs, you lose a globally unique short channel IDs. But there's a trick where you can use the numbers beyond the block limit. So if you've got say, rounded up 4k transactions in a block, then you can use a short channel ID. So you see you prove this UTXO, and then you use UTXO plus, like, as if it's transaction plus 4K, or 8K, or 16K, whatever, you end up with about 10 bits worth. And those are basically shadow SCIDs. And so if you ever see one of those, It doesn't come with a proof, but you know where to find the proof, right? You're basically saying it's linked to this other one, right? So you can figure out what the master short channel ID is, go find that channel and check that that's valid and everything, and then you can accept the kind of shadow short channel IDs. So, and that gives you a pile of bits. And all you have to remember is how many transactions in each block, or actually how many bits worth of transactions in each block.

Speaker 0: 00:56:40

Can you, I mean, the annoying part is like, many nodes don't have the full block data. So you don't know how many transactions were in the block. Can we just hard code that?

Speaker 3: 00:56:53

You can guess.

Speaker 0: 00:56:56

It sounds

Speaker 1: 00:56:56

like we're about to create ordinals. It sounds like Rusty wants lightning ordinals.

Speaker 3: 00:57:02

Short channel IDs are ordinals, right?

Speaker 2: 00:57:04

Yeah, they are.

Speaker 3: 00:57:05

I actually originally thought of doing an ordinals-like thing, but it's too much tracking and no one hits iron for that shit.

Speaker 1: 00:57:10

Yeah, you need a big-ass index.

Speaker 3: 00:57:13

Yeah. But you can intuit it. I mean, in theory, right? One day, HandWave, you'd be getting Merkle proofs, and you can't Merkle prove these things because they're off the end of the Merkle. That's why you round up the order of the power of two. So you can't even try to Merkle prove it.

Speaker 10: 00:57:29

Just save one bit, right? We currently allow for 16 million transactions in a block. Is this right? No, I must be wrong.

Speaker 0: 00:57:37

It's the X index, we have three bytes for the TX. And let's just shave a bit off of it and call it a day.

Speaker 3: 00:57:46

Sure, we'll use the top bits first, right?

Speaker 6: 00:57:49

Yeah.

Speaker 3: 00:57:51

Cool. Two bits, because you may want, depending on what your factor is, right? But yeah, a handful of bits. Yeah, cool. But yeah, so that was the only new trick.

Speaker 1: 00:58:06

Cool. The CLTV thing, we're bumping up towards the end also. I think we know the values everyone has. Everyone seems to have the same value. I think this thing advocated doubling it. We said we don't need to double it. And I think

Speaker 6: 00:58:24

it looks okay. Can you say

Speaker 1: 00:58:24

the updated

Speaker 0: 00:58:24

VR to not double it?

Speaker 1: 00:58:26

Yep, it's updated to not double it. It has a rebase conflict artifact in it. That's the only thing I see at a glance. Okay. Errors, Yoast isn't here. I don't think there's much new here. Looks like, guess what, we have Async. Async has an implementation too, which is cool. I think there's a feature bit conflict as well, Which we should make sure is resolved. Yeah, this isn't like in the next one, the release, so we got time. This thing, I think this was finally updated. This is

Speaker 0: 00:59:26

9.19.

Speaker 5: 00:59:29

And now we have two acts. And it looks like it was separated from the rest of, yeah. It's looking good.

Speaker 1: 00:59:45

Yep, okay. So is this ready to get in? I think on our team, Keegan looked out last. And I guess, yeah, Iraq is very old also. So you've

Speaker 6: 01:00:04

been here.

Speaker 5: 01:00:05

Okay, I'm looking at it again to see if anything changed, but it looks like, yeah, it's looking good. Yeah, here's what I remember. Yeah, I'm gonna actually do it.

Speaker 1: 01:00:25

All right, so I'll pass the merge baton to you, T-Pass.

Speaker 5: 01:00:30

Okay.

Speaker 1: 01:00:33

I think we all do this in some form. I think it's good to like, you know, for posterity, you know, catalog it somewhere, but...

Speaker 5: 01:00:40

How old is that PR? October 4th, 2021. Yeah,

Speaker 1: 01:00:44

that's pretty old.

Speaker 5: 01:00:46

It's still young.

Speaker 1: 01:00:50

Yeah, it needs to ripen.

Speaker 3: 01:00:52

It needs to age a little bit, you know.

Speaker 1: 01:00:55

Yeah, we can put it back in the barrel.

Speaker 7: 01:01:02

Cool, cool, cool. Check.

Speaker 1: 01:01:07

Can already establish this is my very long term homework for TVast that I haven't followed through on yet. I'm almost done with my top route saga, so now I can go back up right here and check this out actually. Cool. I guess anything else in like the last, the final round here, Lassimotus?

Speaker 3: 01:01:30

We did skip over offers, but I did do test vectors for offers,

Speaker 6: 01:01:34

which is

Speaker 3: 01:01:34

always a pain to write because you got to write all the ones that are invalid, and they're really friggin hard to generate. But I did put those up. I also need should really do invoice requests and invoices like the same thing. Here's all the valid ones. Here's all the here's all the fields, here's all the invalid ones. So there probably will be a couple more PRs, but there were no surprises in implementing it. It's just a fairness thing, right?

Speaker 1: 01:02:05

Cool, okay, I just heard that and I posted my stuff too.

Speaker 5: 01:02:11

Cool.

Speaker 1: 01:02:14

Anything else? I think people are going to be at TapConf also. Personally, I have major FOMO. I have a conflict thing, unfortunately. So yeah, I'm already feeling FOMO. I mean, cause it was, it was dope last year. Okay, cool. If that's it. Oh, real quick. Someone made a thing around like something about matrix IRC library doesn't work. I thought like that was just like a thing right like you can just practice or something like that. I don't know how that works exactly. Oh, they disabled the bridge.

Speaker 0: 01:03:03

They disabled the bridge because the matrix people don't have the resources to maintain anything that they've built.

Speaker 1: 01:03:14

Is that something that like one of us can run or like yeah yeah

Speaker 0: 01:03:24

no the bigger issue is like spam and some other crap as long as no one wants to spam us we're okay and we're okay and it'll be easy. Let's just hope we don't have a spam problem.

Speaker 1: 01:03:37

Okay. Okay.

Speaker 0: 01:03:41

If we get hit with a spam problem,

Speaker 6: 01:03:46

we'll have to figure it out.

Speaker 1: 01:03:48

Okay, but no immediate action needed now, I guess. Yeah, okay, manual I think.

Speaker 7: 01:04:03

I think you've said it

Speaker 5: 01:04:04

enough, that's the right approach.

Speaker 1: 01:04:18

Okay, cool, all right. I guess I'll see y'all on chat and stuff.

Speaker 6: 01:04:24

Cool.

Speaker 1: 01:04:25

Thanks, y'all. Cheers.

Speaker 3: 01:04:28

Thank you.
