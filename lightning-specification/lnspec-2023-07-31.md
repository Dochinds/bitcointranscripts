---
title: Lightning Specification Meeting
transcript_by: carlaKC via TBTBTC v1.0.0
tags: ['lightning']
date: 2023-07-31
---

Speaker 0: 00:00:00

Proposals and stuff. Great. Do we want to start with simplified, option simple? I'm just going to go down this list. Stale proposals waiting for interop long-term updates. I guess, Does anyone have anything urgent stuff that we want to make sure we get to in the meeting today? If not, I'm just going to go ahead and start working down the recently updated proposal seeking review list. Great. OK. First up on the list is option simple close. This is from the summit we had a few weeks ago in July. Looks like Rusty and T-Bass have commented on this and roast beef stuff. Does anyone have an update on this?

Speaker 1: 00:00:50

Which one is this?

Speaker 2: 00:00:50

I think

Speaker 0: 00:00:51

this is 1296 option simple close.

Speaker 1: 00:00:56

Yeah. I took a look at it before this. I think I just become really just in the prior one around kind of basically making feature bits required versus removing stuff. Because the last commit here ends up like removing the old one entirely. It feels like we can basically do feature bit gating, and then eventually make this required. I think the other question for this one is also like, what are operations wise? Do people plan implementing this before taproot channels or after? Or is it just like something that we'll examine and then check out and then commit to there? Because depending on that, like we could modify the fields, for example, because like right now there's like a signature field that's like directly coded in and that could be a TLV. Because for taproot channels, one's a partial sig in theory, the other one is just a regular sig. Partially being bigger than a regular sig because it has the non-sign on the taproot.

Speaker 3: 00:01:42

I think that part of the motivation for this was to provide a better close for taproot. So I think we should assume that everyone's going to have this for taproot.

Speaker 1: 00:01:53

Yeah, I guess I was referring more before or after. Because if we think before, then it can make sense to make this a bit more flexible. For example, make the SIG fields a TLV, and that way you can just have the remote one optional or not, and then also you have the partial SIG there. Well, if it's after, then yeah, it's order of operations there. Maybe it doesn't really matter as much, but it feels like if we're not coupling it as tightly, we could make certain fields TLV, mainly the signature fields, to allow, for example, right now, I think there's a bool that says, is my SIG attached? But that could just be a different TLV field. And then you just check if that's not there or not. Or I think it's called like close EC or something like that.

Speaker 3: 00:02:36

Personally, I don't care about TLB versus whatever, but we will probably be implementing this before taproot or at least like it'll be a separate PR that gets merged first. Same release or not doesn't really matter. But I would imagine most folks aside from maybe L&D will implement this pre-taproot.

Speaker 1: 00:02:56

Gotcha. Cool. Yeah, and I think the other thing that we're just like potentially gating certain sections a bit more. But yeah, I guess the main thing is that like, I don't see everyone switching over to this overnight. So it feels like it makes sense to have like a feature bit and then make that required over time versus like assume people are switching over overnight and then deal with like, well, yeah, I guess it's removed, but yeah. I was thinking about, I kind of like the transition basically. I'm not sure if this, yeah. Yeah, because right now it defines the feature bit, but it doesn't get any of the behavior on that feature bit, which makes it seem as though like, once this is merged, quote unquote, this is the thing versus the negotiation to then assume that you're using this new version of it. I love the comments on there at least. It looks like Rusty's not here, so.

Speaker 2: 00:03:48

Yeah, also there is also a debate about what happens if we send multiple shutdown messages with different scripts. And We discussed on the PR that, okay. It's Rusty here. We discussed on the PR.

Speaker 1: 00:04:07

We're talking about the simple close. Yeah, sorry, Vincenzo.

Speaker 2: 00:04:11

Yeah, no, no. We discussed on the PR that if I send a second shutdown, I invalidate the previous one. And when we return the message from the receiver, we need to confirm the script public key where we send the closing transaction. Does it make sense also to avoid concurrency?

Speaker 4: 00:04:33

Well, the idea is you would always send one, right? So you send it and the answer is, so it does two things. One is when you send shutdown, you need to clean up your HTLCs, blah, blah, blah, right? But assuming that that's already done, when you send it, the response is the closing message, right? So there's always like a one to one. Now, Rusty, so so we had that something in there saying you should never retransmit, but that conflicted with the requirement above that you retransmit on reconnect. So that was a separate cleanup. That's like a this was never that you could never meet that requirement, because you're always we said elsewhere, Hey, you're supposed to retransmit this when you reconnect. And it's like, yeah, well, you can't have both. So. So the idea now is that basically, if you reconnect again, you send shutdown again, which you're always allowed to do anyway. But it'd be nice if you could basically, because we're looking at nonces, right? You will always start doing that sequence. You will always send shutdown and start the shutdown sequence again from there, rather than just connecting and sending closing signed or something. So if we're doing that anyway, it makes sense for you to, at that point, be able to change where your output goes to if you really want to. Like basically use the last one, the one that you're responding to, that's the one that you're going to use. Of course, modulo the checks when you receive that you check that it's if they've done an upfront shutdown key, then you know, you fail and stuff. Sorry, the reason I was late is I was actually pushing a couple of quick type faster. I didn't do the TLB thing. I think it's a good idea, roast beef. But I was like, let's do the minimal stuff that's obviously wrong. And then argue on the call about, what do we want to do about the stupid case that will never happen, but everyone wants to bike shit over. Of like zero, like neither of us wants anything from this channel.

Speaker 1: 00:06:19

Yeah, I didn't get that, so I didn't comment on it.

Speaker 4: 00:06:23

Well, it's like, it's theoretically possible, right? I mean, I say, I don't care about my output and you say, I don't care about my output and then what do we do? We could say, well, don't mutual close, you're fucked. But it's nice to clean up the UTXO set. But one option is to say you can't omit your own if you're higher. So one of you has to have an output and just say you can't opt out of your output if yours is the greater output. Like so, you've got two output amounts. The other thing that we're thinking about is we could put more information in this so that you could do a mutual close even if you've lost your channel state.

Speaker 1: 00:06:57

Is that like Decker's Sigash Nunn idea thing or different?

Speaker 4: 00:07:01

No, this is different. I mean, the thing is that we think about this recovery case where you like you rather do a unilateral close, you might want to go to your peer and go, hey, let's mutual close. But you don't if you've really lost your channel state, you don't know what the balances are. We could put the balances in this message. So your peer will tell you at this point when you hey, let's shut down. It sends a thing going, yeah, let's shut down. Here's the balances. You're Oh, sure. Right. Okay. Fine. I'll sign off on that.

Speaker 1: 00:07:25

And if they accept that she's just breach anyway.

Speaker 4: 00:07:30

Yeah, it opens a whole other can of worms.

Speaker 0: 00:07:32

I don't

Speaker 4: 00:07:32

know if we want to go there, but I thought it was probably worth mentioning as a thought, right?

Speaker 1: 00:07:37

And so, Rusty, the other question I have on this one is that like, you know, why doesn't this have like desk rules to proceed any of this amid my output or not, Right? Because aren't we relying on the desk field check anywhere? Are we saying that like, this lets us update that after the fact, whereas right now, like it's basically hard coded, the desk values?

Speaker 4: 00:07:53

Yeah, so the thing is that at this point, you have a lot more information, because you know exactly how much it's going to cost you to spend the output and all that stuff, because the desk, the desk field is used one, it's static. And two, it's used for like, you know, HLCs and all these other things. At this point, you're like, I know exactly how much it's gonna cost me to spend this output. I can exactly tell you whether or not I care about this, you know, this output now. So it kind of makes sense to just have a flag and say, yes, I want it or not. The downside is, of course, that you can't hand your, so because you're supposed to sign each other's, I had to add this. You can't tell them, yes, I want my output if it's dust, because then you're handing them an output as something that won't propagate, right? So you do have to unfortunately have a dust rule in here as well, which I added in a commit like three minutes ago. So yeah, it is kind of ugly. But there's a whole branch of questions. And I kind of picked one in most cases. And if people have really strong opinions on what to do in these cases, I'm happy to change it. I do want to change the signatures to TLV, so we can omit, figure out what we're going to do. I mean, we could just go, if we both don't want our outputs, I'm not going to sign it. And we just, you know, we just, the UTXO just goes, stays around forever. If it's that uneconomic for both of you, no one's going to unilaterally close anyway, I guess.

Speaker 1: 00:09:20

The other question I had, which I posed a bit for Jordan, is like, all right, so right now it adds a feature bit, right? It doesn't really seem to use that feature bit. It just says this is the way it's going to be. But like, So the question I posed to people, I think it was like, are they going to do this before or after temporary channels in turn to like actually know when this is going to be updated because otherwise we'd basically gated everything on the feature bit existence. But if you do the feature bit, you basically do this new thing. Otherwise you do the old thing. Cause I think the old thing is going to stick around for a bit, potentially. I mean, we haven't even done theory yet, and we have a PR for it.

Speaker 4: 00:09:50

Yeah. So I figured, I mean, that's why I did it as separate commits, right? I added it, and then in a separate commit, I removed it, depending on whether people wanted to go for modern, clean, idealized spec, or whether they wanted ugly, dirty spec that we clean up later. I don't have a huge opinion. But yeah, the transition is not going to be... I mean, I think you probably do it around the same time. It's kind of like, it's normally kind of independent. Like it, it works either way. If you've got both, I mean, you could say, hey, if we're doing taproot, and so it's really up to you guys, because you guys are kind of leading on taproot. If you guys go call now, this is gonna be the only way to close on taproot, then you go call this is dependent feature. And if you've got taproot, you've got to have this. And that's the only close we're going to implement and life's a lot nicer. And that implies that you're going to put a TLB in the shutdown to say, here's your nonce or nonces, whatever we choose.

Speaker 1: 00:10:46

That makes sense. You know, right now in my brain, I've at least just updated the close text to be RBF. I need to do that on the spec as well. I guess then we'd say, okay, well, if you're doing taproot, we'd make this a required bit potentially. That'd be one way to enforce it there. I still probably see that. It seems pretty simple. I think I'll probably just start with a completely independent implementation even of StyleFar and normal co-op closed down. See what that looks like. Because it's just kind of like a one-shot thing. And then it just keeps going.

Speaker 4: 00:11:14

Yeah, I want to play with it as well. I mean, I missed the whole too small issue and stuff like that. So, you know, there's a lot more bike shit. This was supposed to be simple.

Speaker 1: 00:11:25

What's this thing around this game theory? I haven't read the comment, but it looks like a long comment.

Speaker 4: 00:11:30

It's like, you know, so, oh, because you're paying your own fees, you're like, well, I really want you to close and I want you to close kind of shit. Now, the thing is that in the unilateral case, the opener is paying all the fees. So they have an incentive to do this anyway. Now, if I really, really want, don't want to pay for the close, but I want a mutual close, it's simple. I just propose a fee that is below one set per byte. And if I really don't want to pay fees, I propose a zero fee, close. And you sign off on it. Great. Good. Right? Now, the opener is not going to propose a zero fee, because that would be dumb. Right? But you could totally, there's nothing in the spec that stops you doing that. If you really, really, you want to close, but you don't want to pay anything, propose a zero fee. Whatever. I don't care. I'll propose, the opener will propose a fee that's maybe de minimis, but they'll want to propagate. So it still works. People are really upset about the game theory, but it doesn't add any new things we don't already have, where you already try to convince the peer to, you know, to force close and stuff like that. I think there's no game theory-free version

Speaker 0: 00:12:52

of

Speaker 4: 00:12:52

closing, and so make it simple.

Speaker 1: 00:12:57

Yeah, I need to follow up or just understand the whole op return thing a bit better as well. That's the only thing that was like new to me. Or to, you know, what

Speaker 4: 00:13:06

would you say, would you

Speaker 1: 00:13:07

just like give it to miners or effectively? Yeah. I mean,

Speaker 4: 00:13:10

it's the only way of doing it because if you both say you don't want the output, you got to have something.

Speaker 1: 00:13:15

Oh, this is for the give up channel case.

Speaker 4: 00:13:17

Yeah. This is where I go. I don't want my output. You I don't want my output either. And it's like, well, OK, well, then what do we do?

Speaker 1: 00:13:23

But I guess doesn't doesn't like the practical min channel size that people seemingly have. I think ours is 20k. Maybe it's.

Speaker 4: 00:13:31

This This should never happen. No one should care, everyone is stuck on it. So there are two options. Well, there are a number of options. I mean, so, okay, looking really long-term, you're gonna want to do not close this way. You're gonna want to have an option to close via splice, right? Where you splice to nothing. So you can construct your dream transaction that does whatever crazy wild thing, right? That's, this is not that. Right? So people said, oh, we should do, you know, C cache single, whatever. No, no, that's, if you really want to construct some fancy transaction, then tack that proposal on the end of the splice stuff and do it that way. This is simple, right? But we've got to figure out something. Now, one way is to say that whoever has the higher balance cannot omit their output. So there always has to be an output. That's simple. I don't care. No one should care. Like it's not gonna happen except in test scenarios where you've opened like a, you know, a 500 sat channel or something stupid.

Speaker 5: 00:14:43

Isn't the network minimum 20K?

Speaker 3: 00:14:47

So, L- No, there's no network minimum.

Speaker 1: 00:14:49

Yeah, so LNB has a 20k

Speaker 0: 00:14:50

value, Keegan.

Speaker 1: 00:14:50

Got it. Oops. Yeah, but I was thinking like, you know, in practice, because we have a 20k minimum, it probably doesn't matter, but I was just like, cover all the bases or whatever.

Speaker 4: 00:15:00

I think we can do it on testnet.

Speaker 3: 00:15:04

I think we have a bunch of checks, so we probably end up with an accidental minimum that's some function of fee rates and there's probably something like that, but in practice.

Speaker 1: 00:15:14

Or just 20k hard-coded.

Speaker 3: 00:15:17

But even 20k, like, fees go up a bunch. It wouldn't be hard to hit a useless channel in 20k.

Speaker 4: 00:15:26

Yeah, but you would just lib all your fees, right? You'd be like, well, I may want this eventually. I'll do one set per byte, right? The thing is that there's no cost, there's no... Okay, other than propagation, you know, hand wave, right? If it was min fee. But in theory, right? You close now, And you child pays for parent when you actually want to use the damn thing. It doesn't cost you anymore. It's almost always the right thing to do. I think you'll end up closing on minimum fee almost all the time. And if you want that output, that point you start paying for fees. Otherwise, you wait. Maybe there's some UX issues. People like to see things confirmed. But as far as I can tell, you want to close on a low fee enough to propagate. And if you don't want the output this week, then Leave it.

Speaker 1: 00:16:17

Yeah, it feels like, yeah, I guess what's the line between like just doing a low fee or giving up explicitly by, but then like, you know, will that even confirm your, your maybe low prioritizing? I don't know.

Speaker 4: 00:16:28

It makes me feel good to know we're not leaving a UTXO out there, you know, that, that that's never gonna get spent. That's, That's why it's there. But yeah, if you're hitting this case, you're doing something wrong.

Speaker 1: 00:16:43

Cool, okay, I'll check out the new set of stuff as well. And then think about the dependency of making the bit required, et cetera, or at least assuming that for the separate stuff or not. And then probably good just to see what the nonce flow looks like as well. But it should be more or less the same. I mean, just kind of like a single shot thing, which is what we have today, where we basically just have the responder always agreeing with the initiator's days, and that's just like, makes the roles explicit, you can say.

Speaker 4: 00:17:10

Yeah, yeah, I reckon you throw two nonces in the shutdown and you use those pair, or, you know, we're gonna TLB this, and we may end up with, oh, not always having two things, in which case You don't use one of the nonces. That's easy, right?

Speaker 1: 00:17:24

Yeah, they can be fully random so

Speaker 0: 00:17:26

yeah

Speaker 1: 00:17:30

Cool So

Speaker 3: 00:17:32

yeah, let's let's thrash it

Speaker 4: 00:17:33

out on issue because there's a whole heap of kind of, wow. Yeah, I think there's a lot of stuff that people want to discuss, most of which I don't think is important, but you know.

Speaker 0: 00:17:45

Cool.

Speaker 1: 00:17:46

Okay, I'll check that off. We've got some notes here.

Speaker 0: 00:17:49

Ready for the next one? I mean, not that we need to introduce it, but next one up is specified behavior when a node specifies both optional and required features. Vincenzo, do you want to lead this discussion?

Speaker 2: 00:18:04

Oh, yeah. I think it's a very much CPR. Basically, with LMProtest, I noted that we don't have any requirement if we set if we send a feature bit as required and as an optional feature bit in the same feature set. And I was thinking that we should have something because bugs can happen, right?

Speaker 0: 00:18:34

Should have something because, yeah,

Speaker 1: 00:18:35

bugs can happen, right? And yeah. Yeah, I don't think we ever actually rejected. It's only like the unknown required case. Yeah. But-

Speaker 2: 00:18:46

Correct me, I accept them. But I don't know what is the behavior with I think we take the required one. But I don't know. I run a couple of tests with a number of tests and with CoreLigand both succeed. So, I mean...

Speaker 4: 00:19:04

Yeah, if you've got the mandatory, we take that. It's undefined what happens if you set both. And we kind of left that open in case we came up with some really clever thing to do with both. Like, because it's really a trinary, not there, optional or required. The fourth case is undefined. I'm happy to say don't do that. And if we ever come up with a reason to do it. And yeah, I think it's pretty clear that if it's mandatory, you treat it as man, like, well, yeah, it's undefined. If we want to say, yeah, sure. Obviously, if the compulsory bit is there, you shouldn't ignore it, right?

Speaker 3: 00:19:38

So if you don't

Speaker 5: 00:19:39

understand it. Yeah, I mean, you can think about it, you can think about optional as can do versus the mandatory bit as must do and like must do will subsume can do in every case.

Speaker 4: 00:19:50

Yeah, exactly, which is why setting both is weird. But yeah, it's just an undefined corner.

Speaker 2: 00:19:56

Yeah, in the PR I define this and maybe in the, I don't know, to me it makes sense to have this, this set of rules, I don't know. Maybe also it's good to catch some bugs if we set both. We can always remove it. I don't know. If we think about something that can be useful to set both. Because if it's required, that can be optional for some nodes, right? So if I know the say, hey, I require these, you cannot say, okay, this is optional for me. You need to specify it always.

Speaker 1: 00:20:42

So. Yeah, maybe both is assumed, which I guess we'll talk about in a second here. One question, you know, not fully related to this, but like have people fully ripped out legacy onion parsing from their node? If I try to send you an onion with legacy onion parsing, do you just choke on it? Do you send back a fail? Just curious. Cause I think that's really the- choke.

Speaker 4: 00:21:03

I think we bad onion it, I think.

Speaker 1: 00:21:06

Bad onion?

Speaker 4: 00:21:06

We get upset. We're like, what the hell is this?

Speaker 1: 00:21:10

OK, OK. Yeah, because we're like that.

Speaker 0: 00:21:15

I doubt it's bad.

Speaker 3: 00:21:15

Oh, probably bad onion? I

Speaker 1: 00:21:17

don't know. But we definitely have to call it bad onion. It's either bad onion or malformed onion, whatever the name is.

Speaker 4: 00:21:21

Yeah, it's one of those ones. Yeah.

Speaker 1: 00:21:24

Yeah. I think I was curious. I think we're looking to actually remove it. I guess we can set the bit to required first, which maybe is related to the thing around the assumption stuff, which is the next thing. OK, but so for this one, we're saying it's OK for now. We'll think about something, or do we want to have it be airtight?

Speaker 4: 00:21:50

I'm relatively happy for it to be undefined. I'm trying to look at where we say set the feature. Generally we say we test the feature bit and so if they're both set then it just kind of works but it's kind of nice to be explicit. Don't.

Speaker 1: 00:22:07

Yeah, whenever we do like exists, we do like both versions of the bit.

Speaker 4: 00:22:13

Yeah, we have the same kind of test, right?

Speaker 3: 00:22:15

Yeah, but I don't

Speaker 1: 00:22:16

think we fail if both are set. We just carry out one of

Speaker 3: 00:22:19

them is set. And then

Speaker 1: 00:22:20

elsewhere we do the unknown feature bit check.

Speaker 5: 00:22:22

I think following the principle of being permissive with what you accept, we probably shouldn't fail if both are set. As long as the rest of the semantics are congruent with the mandatory bit.

Speaker 4: 00:22:37

Yeah. I mean, don't send it, but if someone does.

Speaker 2: 00:22:41

The PR is not saying that we should fail. But if both are set, we take the required one. It's a pretty trivial one. So you should do it either way, right? Is if I know, say, hey, this is required for me. Also, if I specify that this also optional for me, it's required, right? I don't think the PR said that you should fail, but maybe wrong.

Speaker 1: 00:23:21

Well, yeah, you're saying, basically you're saying like, you shouldn't set it, but you shouldn't reject it. Right now, this PRC is

Speaker 2: 00:23:27

also set. If you set the receiver, need to take this like, hey, you want this as the quad. I don't care if it's also optional. So just in your, the optional one.

Speaker 4: 00:23:46

Okay. Yeah. So looking through the spec briefly. Yeah, we, we talk about rejecting. Evens and everything else. We never define what negotiated means, but we assume everyone knows what negotiated means. We should probably define that somewhere.

Speaker 0: 00:24:00

When we

Speaker 4: 00:24:00

say a feature is negotiated, which is language we use, it means that they basically, you either both set it to optional or you both set it to compulsory. You both set it optional or compulsory, right? You don't care. But yeah, it basically implies you both set it and therefore it's negotiated. And since that isn't defined, it's like, I think everyone's basically doing that test, but it might be good to spell it out. So basically,

Speaker 1: 00:24:28

we have that. Yeah, we can.

Speaker 4: 00:24:30

Yeah, so we have a thing in our, we have a feature is offered if it's, if it's set, if we've set it, or if whoever we're talking about has set it, either optional or compulsory. And if we both offered it, then it's negotiated. Right? So that's the language that the spec kind of is heading towards. And maybe we should just nail that right down. You know.

Speaker 5: 00:24:55

Just as a quick clarification, are all the currently deployed features like strictly independent? Or do some of them imply other ones?

Speaker 4: 00:25:07

Yeah, there's Bolt 9 actually specifies.

Speaker 5: 00:25:10

So then presumably any mandatory feature bit can also imply mandatory all the way down the dependency stack?

Speaker 4: 00:25:20

It could, but you don't have to. Although, like, you know, it doesn't, it doesn't, like, presumably, everyone accepts it, right? The only difference in mandatory and optional is that if they don't understand it, they should behave differently. There's no other signaling on that. So presumably, if you've specified a higher level one, they understand that one, otherwise it would have hung up on you. And so the lesser one, who cares?

Speaker 5: 00:25:49

Right, yeah, I guess it depends on like how sort of nitpicky we want the protocol to be. But like, Are these dependencies listed explicitly in bold nine? Yes.

Speaker 1: 00:26:04

So every bit has something that lists dependencies, basically. And then we have logic for that in LND as well. It's like deps.go, I think, is where that is.

Speaker 4: 00:26:15

It's a lot easier than trying to deal with all the test metrics of, oh, but what if you offer this and not that and stuff like that. So in some cases, it's just like, be modern, offer the modern set.

Speaker 5: 00:26:27

Yeah, I don't think it would be tremendously terrible to require a consistency in the feature bit set that you offer. Like if you're mandatory in the downstream dependency then you should probably be mandatory in the upstream one.

Speaker 1: 00:26:43

I see what you're saying. You're saying require, yeah, yeah.

Speaker 5: 00:26:48

Like I think you

Speaker 3: 00:26:49

need to accept both right now.

Speaker 4: 00:26:50

I mean feature bits are like a really crude hammer right it's like literally if you don't understand this I don't even want to talk to you which you know in practice is the last stage right because usually and we hit this recently because usually you're like well maybe I don't want to open new channels to you, but if you've got an existing channel with me, I still want to talk to you. So really you've got to have everyone upgraded before you can really start top mandatory. The exception is if you were writing a new implementation or something and you're like, well, I don't care about old nodes and I'm gonna be ahead of the curve, sure. But yeah, we've discovered it's a pretty crude, crude hammer.

Speaker 1: 00:27:37

Cool. And

Speaker 5: 00:27:38

these are like node, right? Not per channel.

Speaker 1: 00:27:41

There's like, there's different levels. There's like node, init, Channel update. Yeah, there's like a little column in nine that like tells you where it should go basically. I-N-C or nine or something like that. I don't know exactly.

Speaker 4: 00:27:55

Yeah.

Speaker 1: 00:27:57

There's like invoice, their announcement and then something, something. Okay. The next one?

Speaker 0: 00:28:07

Next one is site cleanup, removing unused features. Oh wait, did we just finish that one? You guys are like...

Speaker 1: 00:28:17

This is related but different.

Speaker 0: 00:28:19

Yeah, okay. So this is like removing unused features and assuming four more ones on 192, 1092.

Speaker 1: 00:28:28

Yeah, yeah. Something we talked about just in terms of cleaning

Speaker 4: 00:28:30

stuff up.

Speaker 1: 00:28:30

My main thing for this is that like, it feels like there should be the intermediate phase of required. Cause it feels like we never really did require. Looking at our bits right now, like the only thing we have required is like the payment secret or people call it in the invoice. And nothing else, for example, like, you know, now we can theoretically set TLV and then payload to require, you know, in our next release and just start there or something like that. There's probably some other ones that we can make required, like static key required, whatever else.

Speaker 4: 00:28:58

Yeah. I wonder if we want to flip them onto required. I'll leave this on the back burner for a bit, flip them on to required, see if, see what happens. And then once everyone's like, no, it's required, then we go, cool, let's just start assuming it. Yeah, exactly. That's effectively the same.

Speaker 1: 00:29:12

Yeah, because remember one time, like we, I think we had a bug with a clear where like, we flipped them to required basically, right? But then we had an existing channel that was legacy. So we couldn't even have a TCP connection at all with them. Right. So this could reveal other kind of like edge cases there. So yeah, I mean, I'm in favor of like a two phase thing, you know, get the required set of stuff, which should be like, you know, pretty small change for everybody, flip that on. And then we can look at like, you know, burying it or whatever.

Speaker 4: 00:29:38

Yeah, it was more about which ones do we want, right?

Speaker 1: 00:29:41

Yeah, I think this is like the set that like, everyone does. The other thing I checked on here, I remember we talked about Rusty, sort of codifying the whole thing around gossip timestamp in terms of behavior, and in terms of like, send me everything or don't send me anything. I don't know if there was a third one.

Speaker 4: 00:29:56

Yeah, there's like, yeah, yes. We've implemented that, but I'm a mere suspect. Basically, if you give us like zero, it's like, or zero is like, yeah, give us everything. And like FFFF is like, give us nothing. And then any other number is like, I'm just gonna start streaming from now on. We actually go back a little in time. We give you like the last hour or something. Like very rough heuristic. We kind of keep, we go back a little bit because that's what everyone does. They either send the current time to say, yeah, yeah, from now on I want to know, or they would want everything or they want nothing. So, or the other, the other exception is of course we always send you anything about our channel. So our channel updates, we send immediately. And as of this release, we're going to send you our node announcement, which we forgot to send. And that propagation sucked. But we're also going to send our peers channel update, which we didn't do. So we'll send you all the messages we generated, but we'll also send our peers side of the channel because that's important too. But yeah, we span that to everyone when they first connect and then we obey whatever they ask for.

Speaker 1: 00:31:07

Yeah, we basically use it to control like where we get updated from. So we'll like rotate and stuff like that. But I mean, so I guess, Russell, you're saying that, you know, collating doesn't do any backlog at all or it's just kind of like you pick the backlog size?

Speaker 4: 00:31:20

Yeah, we do. I'll have to check. It's like a couple of hours. We basically keep a trailing pointer of like a while ago and we update that slowly. So no guarantees, but you'll get a little bit in the path. The idea is like, if you rebooted your node or something, you're really not going to miss anything.

Speaker 1: 00:31:37

Sure, sure.

Speaker 4: 00:31:50

Yeah, this was also about banning the idea that you can ask for everything.

Speaker 1: 00:31:56

Yeah, that's, yeah, I realized that wasn't just like deleting stuff and not necessarily like the updated interpretation of what, I guess, we're at least like restricting that somewhat.

Speaker 4: 00:32:05

So yeah, I wonder, I mean, I've always thought that's reasonable, right? Like, so first time you send it, you can send zero to say, sure, give me everything, but you can't do that again. Like whatever, Like you're not getting it. I'm not gonna go back and do that again. Like, I mean, maybe. Like, I don't know, should we have just some general, it's just generally pretty antisocial. Like you want them to be able to basically say, give me all the gossip, that's probably fair. Although you might wanna rate limit them.

Speaker 1: 00:32:33

Yeah, if they're asking for it too much, then yeah, that's not good.

Speaker 4: 00:32:38

But there's a whole heap of things they can ask for too much, right? I think we should probably need to be more general and just kind of whack this one.

Speaker 3: 00:32:45

So we currently do, I think we request, for the first like three peers we connect to, because we don't really have any idea when we last synced. I mean, We can take a guess based on the timestamps of nodes we have.

Speaker 0: 00:33:08

But

Speaker 3: 00:33:08

I think we shouldn't overthink this and we shouldn't actually build a real gossip protocol so that we can do a proper thing.

Speaker 4: 00:33:18

Yeah. 1.5 it's coming.

Speaker 1: 00:33:21

Well, I think he means like on like the PD. Yeah, I know, I know Claire has some other stuff too, but- Well,

Speaker 3: 00:33:27

we need 1.5 first to do height-based things and then we can do a PDP-based sync. That actually makes sense.

Speaker 1: 00:33:34

Yeah. You mean like an actual thing or something even beyond?

Speaker 3: 00:33:39

Well, something very scant face.

Speaker 1: 00:33:42

Oh, sure. Oh, then we have blocks. Sure.

Speaker 0: 00:33:46

Should we move on to the next one? Cool. Is there any actions or items we should take from this back cleanup stuff? Or is it more discussion in the paper?

Speaker 4: 00:33:57

I think the answer is we should make them all those bits compulsory and see what happens.

Speaker 1: 00:34:03

I think it's like required. Let's see what happens. And then we can say, okay, now it's actually required. Now we have the bid set and the network didn't explode for whatever reason.

Speaker 0: 00:34:14

Yeah. Cool. Okay. Then make a comment on that. Sounds good. Okay, so next one is correcting the final TV for blinded paths. Basically, two PRs which both seem to build on the same prior PR, which is 1066. Are Carla or Val available to talk about these?

Speaker 6: 00:34:40

Yeah, so 1097 is mine, and it actually replaces

Speaker 0: 00:34:44

1066.

Speaker 6: 00:34:46

It's pretty much exactly what Matt's PR had with the update that we spoke about at the summit. So I think if maybe Ress, you or Matt could take a look at that, it's ready to go. It's just clarifying the outgoing CLTB value for the final hop in a blinded path.

Speaker 0: 00:35:04

I'll be fine to me,

Speaker 3: 00:35:06

but I'll delegate to Val. So this seemed fine to me, but I'll delegate to Val.

Speaker 7: 00:35:14

I act it.

Speaker 1: 00:35:22

So are 1097 and

Speaker 0: 00:35:24

1069

Speaker 1: 00:35:25

the same thing or different?

Speaker 0: 00:35:29

1069

Speaker 6: 00:35:30

is valves and that follows up with something different.

Speaker 0: 00:35:41

Does this peer require changes in what anyone has already merged for blinded path stuff? Or is this just a clarification?

Speaker 6: 00:35:52

I believe it's just a clarification. It's definitely what Async is currently doing. I'm not sure about CLN and it's what Val and I are doing in RPRs.

Speaker 4: 00:36:03

Cool. Then it's correct.

Speaker 0: 00:36:06

Then, yeah, I think, are we okay to apply it then? T-Bus has approved it, it looks like Val's approved it.

Speaker 1: 00:36:12

Do it.

Speaker 0: 00:36:13

Okay, cool, so I think we're good with that one then. Unless there's objection? Nope, okay, That one's ready to merge. I'm going to go ahead and merge it then. That's cool. Okay.

Speaker 1: 00:36:24

Do it.

Speaker 0: 00:36:25

Great. That one's in. Sick. Next up would be the clarify final CLTD X-ray computation. This is Val's.

Speaker 7: 00:36:38

Yeah, I still need to add a few clarifications to this one, but I should be getting to that soon.

Speaker 0: 00:36:46

Is there anything that we wanna discuss around this one for the meeting today?

Speaker 7: 00:36:51

I don't think so. We had some discussions at the spec meeting, but basically the PR is just regarding there's like a field in route blinding that you end up computing with Bolt 12 using the invoice expiration. So you're kind of translating the invoice expiration into block heights, assuming 10 minute blocks. So it's basically just clarifying that. And I just need to respond to a little bit of feedback. Sorry for the delay.

Speaker 0: 00:37:19

No, that's cool. OK, so the two on the sun is a little more discussion on the PR and we should probably revisit it next meeting.

Speaker 7: 00:37:29

Yeah, sounds good.

Speaker 0: 00:37:30

Cool. OK, moving onwards. Harmonize, so more CLT stuff, but this time not for blinded paths. It's harmonizing the max CLTD x-ray across implementations 1086. This is from Antoine. Antoine, want to lead the discussion on this one?

Speaker 1: 00:37:57

I don't think he's here.

Speaker 3: 00:37:59

Not on the

Speaker 0: 00:37:59

call. Is there anyone else then that wants to lead the discussion

Speaker 3: 00:38:04

on this? I think it's in the comments.

Speaker 1: 00:38:08

Yeah, or look at the comments. Everyone has the same value. It's

Speaker 0: 00:38:11

2016,

Speaker 1: 00:38:11

it looks like, right?

Speaker 0: 00:38:12

Everyone has the same value. Yeah, that does look like what the comment says. Okay. This is proposing to change it to 4032. Everyone currently is in 2016, but this is proposing to change it to 4032.

Speaker 3: 00:38:31

I don't think it was intending to change it. I think it was intending to standardize it and it's just wrong.

Speaker 1: 00:38:38

There's something that Dave that says was suggested to be 4032. But

Speaker 5: 00:38:43

yeah, we discussed this at the last spec meeting and I think where we had landed with that we just wanted to get everybody on the same page first and then we can talk about changing the value to a different one like a sort of subsequent discussion.

Speaker 4: 00:38:58

Is there a magic number better than our magic number? I like I don't know how do we pick?

Speaker 1: 00:39:03

Well I mean everyone already does 2016. Yeah.

Speaker 3: 00:39:08

The discussion I recall at the last meeting was let's stick with what we have because everyone has the same number and not less changes. I don't think there's much left to discuss aside from the PR needs to be updated to suggest

Speaker 0: 00:39:18

2016. Okay, so, spagni- Okay, cool. On there, great. Let's see, Attributable errors. I don't have this one open yet. Sorry. This is from Yost. Is Yost on the call?

Speaker 1: 00:39:47

I don't think so, but talking with him and a bit more tech, I think the last thing on this was like looking at like changing up the HMAC or something like that. I think that was like the last thing that came out and I think I discussed a little bit in New York.

Speaker 3: 00:40:01

There's some level of agreement on that, right? So basically this is waiting for Interop.

Speaker 1: 00:40:06

Yep. Yes, and I think the, I think the,

Speaker 4: 00:40:10

I think the

Speaker 1: 00:40:11

PR team

Speaker 0: 00:40:11

is updating.

Speaker 3: 00:40:11

There may or

Speaker 2: 00:40:11

may not

Speaker 3: 00:40:11

be constant changes. Yeah, PR may need to be updated. There may or may not be constant changes, but I think the next step concretely here is interop. Yeah.

Speaker 1: 00:40:21

Yeah, and I think the only PR isn't up to date either yet. But I think he just got the scope of clarification

Speaker 3: 00:40:27

that you're looking for generally.

Speaker 0: 00:40:30

OK, so the summary is it's awaiting interop and some proposed PR changes. Correct?

Speaker 4: 00:40:40

Yeah, needs an update and it needs interop. Sorry, can we jump back to 1086 for a sec. The, expiry too far. Yeah. The magic number. I like the idea of nailing the magic number is fine. I just think it's a one line change. It's not like a whole new paragraph that describes a new variable that everyone needs to set with a discussion. And I really think it's just where we say send this error, you say, if it's greater than

Speaker 0: 00:41:12

2016,

Speaker 4: 00:41:12

send this error. Don't overcomplicate it. Just textually, I think it's a terrible change to the spec. Like, if you read the actual PR, rather than discussion on the number, we have a section on what errors to return. Just have a thing saying if it's greater than 2016 return this error. Done. Like we've already got the checks laid out in requirements. This adds a whole new section with a new variable name in order to give it one number. So anyway, I will respond on that. So I like the idea of nailing it. I hate the idea of adding 20 new lines to do it. So I will respond on that.

Speaker 0: 00:41:56

Yeah, that

Speaker 5: 00:41:56

seems reasonable.

Speaker 0: 00:41:59

Yeah. Okay, great. Thanks, Rusty. That is a good general note for spec writing. Less words is better, I guess.

Speaker 1: 00:42:09

Okay, so

Speaker 0: 00:42:10

we talked about attributable errors. The next one on the list of what to talk about is onion messages, bolt seven. So adding Onion Message support. Rusty, your name's at the top of it. Is there, do you want to lead this discussion?

Speaker 4: 00:42:29

I think we have interop. Rust, I knew, I think there was talk about test vectors being reproduced. Somebody want to talk?

Speaker 7: 00:42:53

I wrote the test vectors for LDK. I think they could use a review glance first, which I'm still waiting on, but they're written and they're, the values that I'm asserting on right now are just the onion messages themselves and the onion routing packet. So not really asserting on intermediate values, but I think that's okay. But yeah, I mean.

Speaker 4: 00:43:17

Yeah, I think it's hard to get the intermediate values wrong. The final one's correct.

Speaker 1: 00:43:21

That's my problem with Onion stuff. Yeah. Yeah. When it

Speaker 4: 00:43:25

works, it works. When it doesn't, oh my god.

Speaker 7: 00:43:27

It doesn't bad HMAC, and that's all you get.

Speaker 6: 00:43:29

Bad HMAC. Go away.

Speaker 7: 00:43:33

So yeah, I don't mind. I mean, I don't know what the normal protocol is if we want to wait for a review or just say that looks good.

Speaker 3: 00:43:42

If it passes, that means our, you know, test code may need cleaning up, but at least the thing passed. So from the spec level, it's right.

Speaker 4: 00:43:51

Yeah, we should, we should, let's get together and do an interop test. Actual real interop, just to make sure that we haven't missed something stupid, Val. So we'll do that offline and we can join some nodes together and send messages and see what happens.

Speaker 0: 00:44:08

Awesome. Well, in

Speaker 6: 00:44:09

the most strange interop way possible, I've used LDK to send messages to CLN and it works through R&D, but maybe we should do a more, a less Frankenstein-y interop.

Speaker 0: 00:44:25

I mean, it's a good question, what counts as interop?

Speaker 8: 00:44:30

Isn't Frankenstein-y good for interop?

Speaker 4: 00:44:33

Yeah, weirder is better, right, surely.

Speaker 0: 00:44:40

Okay, so what are we trying to decide on this one? Is it that we want to do more interop tests? As a, no?

Speaker 4: 00:44:51

I think we're ready.

Speaker 0: 00:44:52

We're good, That means it can be merged, I guess. Yes? Yep. Someone who wants to work on it want to hit the merge button?

Speaker 4: 00:45:02

I would love to hit the merge button.

Speaker 0: 00:45:04

So, okay. This has been a very exciting meeting. Cool. Okay, so I mean, messages are in Unless there's any further comments on that particular item, I'm going to mark it off and move on to the next topic, which is offers.

Speaker 4: 00:45:35

Still waiting on me to write some test vectors. Sorry, which I will do. We have rough interop, but we should still do test vectors.

Speaker 0: 00:45:46

Oh. Okay. So this is pending.

Speaker 9: 00:45:52

I opened up PR2 for reduced software sizes just before the meeting, so it's in the comments on the note, and the meeting agenda rather.

Speaker 0: 00:46:02

I'm sorry, I didn't catch that. Did anyone else catch the comment?

Speaker 9: 00:46:09

You hear me?

Speaker 0: 00:46:10

If you could speak up a little bit, that would be

Speaker 8: 00:46:12

really helpful.

Speaker 3: 00:46:14

I can hear you fine.

Speaker 1: 00:46:16

Some test vector. That's what I got.

Speaker 3: 00:46:18

No, no. Just open the VR.

Speaker 9: 00:46:20

Sorry, let me try it again. So

Speaker 0: 00:46:24

1099,

Speaker 9: 00:46:24

I opened just before the meeting. It's in the comments of the, I guess, of our meeting agenda. It's to reduce the number of flights we use in blinded paths and offers. So that's just one update.

Speaker 0: 00:46:40

Okay so this will be a this is an update on top of or modification of offers so taking the offer protocol and and making it sorry do you want to give a quick summary of what this is?

Speaker 9: 00:46:56

Yeah, we discussed it last meeting. So I don't

Speaker 1: 00:46:58

have much

Speaker 9: 00:46:59

to really discuss now, but I just wanna let you all know that it's available for review.

Speaker 0: 00:47:05

Okay, great. Especially...

Speaker 3: 00:47:10

I got muted in the middle of talking. I'm not sure if we muted him or why he got muted.

Speaker 9: 00:47:14

Okay. Well, let me try it again. So we replaced pubkeys with short channel IDs.

Speaker 0: 00:47:25

That's a nice update, okay. That seems pretty cool. Cool, okay, and then, so this is open for review and hopefully we'll have it on the docket for our next meeting. Yeah.

Speaker 4: 00:47:38

And I've put it on my to-do to actually implement and roll into the test vectors.

Speaker 0: 00:47:43

Cool. And then, okay, so this is an update to the offers PR. I'm sorry, could someone remind me what the resolution is for 798? That's the offers PR for next one. It says I have a pending.

Speaker 4: 00:47:57

Test vectors and this are both pending, so we won't merge it.

Speaker 3: 00:48:04

Because we need.

Speaker 0: 00:48:04

Okay. Just reading comments all over the place. All right.

Speaker 4: 00:48:09

Yeah, we want

Speaker 0: 00:48:10

1099. Okay, I'm gonna edit, depending on, edit. Once. It's 1099. Okay, cool. Great, great. Awesome, y'all. What is up next? It would be adding a dust exposure threshold. This is 919. This is also from Antoine.

Speaker 3: 00:48:38

T-Bass did something about reviewing it, but all of us are reviewing.

Speaker 0: 00:48:41

This is very old.

Speaker 1: 00:48:43

Yeah, it's mega old. T-Bass has looked at it. That's it. I think it's one of the things where it's like, everyone does this already, and this is about like catching stuff up. And it's just a matter of like revisiting, but yeah, I guess it's just in these review state.

Speaker 0: 00:49:04

Okay, looks like there's still some unaddressed comments I left two years ago about changing things where things are. Okay, There's nothing to do on that one, I guess.

Speaker 4: 00:49:20

Do we time this one out?

Speaker 0: 00:49:24

What does timeout mean?

Speaker 1: 00:49:25

Well, it was worth the OP did, and then I said, should we reopen it? But we can let them timeout again. I

Speaker 3: 00:49:33

mean, we should, even if we don't, what's the current text of it? Because the very original text of this PR was like super specific and nothing anyone wanted. If we don't land this, whoever presses the close button should at least add a note. There is an attack here that if you let the max dust exposure go up, you can be hurt. So see this and do something about it. Like, there's a lot of text here, and we could just not have all this text and just have a, like, much smaller thing.

Speaker 4: 00:50:11

I think that was my thing. There was a lot of text and very little action. I like the spec to tell me what to do. Like, just give me a thing. Tell me where I have to check stuff and where I have to stop stuff.

Speaker 3: 00:50:26

I would say this text does roughly that. It has five sentences and then like, here's how you calculate your dust exposure. I guess you could leave out. And then it says like, you know, if you receive a HGLC and it's high, then you have to fail the HGLC if you... Yeah. I mean, I would say it is pretty prescriptive in that sense, but The question is, do you want something super prescriptive, or do you just want to say, like, there's an attack here, do something about it? I think that's a question for Rusty.

Speaker 4: 00:51:13

You always want something prescriptive, right? But, Hey, there's an attack over here you should also think about while you're juggling all these other things that you have to think about.

Speaker 3: 00:51:21

Then I think we have to merge this as is basically. I don't think it's going to cut down that much.

Speaker 4: 00:51:28

Okay let me look at the final text. Okay, Okay, so I promise I will review this today.

Speaker 0: 00:51:36

Okay, okay, cool. That seems like a solid point. Should I note it on the PR?

Speaker 3: 00:51:44

Yep. If Rusty's happy with this, I'm happy to see it merged without anyone else looking at it.

Speaker 0: 00:51:50

Do we time out the

Speaker 3: 00:51:53

requirements for two acts? Can we time that

Speaker 0: 00:51:57

out? No. Cool. All right. So let's keep moving then if everyone else is okay with that. The next thing up is taproot. Extension bolt simple taproot channels 995.

Speaker 8: 00:52:10

I still have one PR up. I mean, it's a minor PR converting the image from Remy JS. Ben, I think we should continue with just using non-sys. I think it's the easiest path forward. And we already have that.

Speaker 1: 00:52:25

That's on my fork, right? Yeah. OK, cool. I'll check that out. But yeah, so I'm going to have this be updated in terms of out of draft and stuff like that this week. So I need to, you know, get this thing in there. I think there's some things around like the co-op close thing, just at least making it an RVF to start with. I just need to go through and just respond to comments generally. And implementation-wise, like we're like doing, we're doing like the last PR, which is like on-chain handling, Which is where a lot of stuff is different

Speaker 8: 00:52:56

Yeah have some I have a an LDK PR that's kind of having some issues with lifetimes and we have several different solutions for that. But yeah. That's fun. Oh my god, it's been so fun. I'll defer to Wilmer about telling you about all the fun because I've had I think I've had all too much fun with that one

Speaker 1: 00:53:23

Cool but I'll ping people, you know, I guess PR IRC whatever else once like nothing is done and you know Then at this point I can just get some test vectors up as well, just for like the various transactions and maybe like do a new JSON vector. Cause I don't think we have JSON anywhere else, right? They're just like the- No.

Speaker 8: 00:53:39

I don't think we have JSON anywhere.

Speaker 1: 00:53:41

Actually, I think- Yeah,

Speaker 0: 00:53:42

that's good.

Speaker 1: 00:53:42

That sounds fun. Well, no, Wilmer added JSON for zero anchor. So that's already there, or at least, I think that's in line. But I was looking to do that for the TX transaction stuff there too. But yeah, so generally, I'm focusing on catching up the spec this week, and just in terms of the minor changes and other things like that. And say, Moosig 1.0, etc., etc., and then, so ideally to be out of draft this week too, which is I think was like my thing to have test vectors on there.

Speaker 8: 00:54:06

Okay, exciting.

Speaker 0: 00:54:09

I have a quick question. I don't know if it's related to this, but has there been any, I know Zeman had an interesting proposal not to use the music too for the commitment transactions.

Speaker 8: 00:54:20

Yeah, that's what I was referring to. I think we should just keep using the nonces because, I mean, it introduces the on-chain footprint. We do have to have some non-scanling code anyway, so it's fairly easy to reuse it for the commitments

Speaker 3: 00:54:39

That we have to have completely set only for shutdown, right so it would be yeah Very different part of the code certainly in all decay it's like a completely separate part of the code base.

Speaker 4: 00:54:49

And it's transient. You never have to persist the notes. That was the

Speaker 0: 00:54:52

huge attraction.

Speaker 8: 00:54:53

That is true. We never would have to persist them.

Speaker 1: 00:54:58

This one feels late in the game. I don't know. We've been talking about it for a year. I know.

Speaker 4: 00:55:05

Zeman, where's your...

Speaker 1: 00:55:06

This is making more sense with the force cloaks, Taproot compared to regular as well because you have the extra up key and then also the control block as well

Speaker 3: 00:55:14

I think people can do it

Speaker 1: 00:55:18

isn't that part of

Speaker 3: 00:55:19

the reason why we're fixing the shutdown stuff to not be as force close happy?

Speaker 1: 00:55:24

Well, yeah, I think it's just like independent of it. It just feels like we felt like we were going to go all the way and stopping halfway because people had trouble implementing or don't want to. I don't really understand what the rationale was. Just like not have to do the non-stuff, you have to do it anyway. To me, this feels very late in the game, given like when we talked about this last year, to say co-op code is different now And then Co-op Code is also different. And then you have more bytes on chain, as well as more expensive. I think once people sit down and look at the nonce stuff, it sounds scary. But I think we've slimmed it down a bunch to what it was before. Credit to, you know, Ark and Wilmer for doing the Jitnons thing and stuff like that as well. But I don't think it's as scary as people think it is. Sorry, I have construction in my fucking window.

Speaker 8: 00:56:12

I kind of agree with Lalo. I think it's nice to have a smaller fucking green lateral close. I don't think the non-stop is too complicated. However, like as before, I'm perfectly fine with dropping it entirely, even though it's late in the game. But I think we should keep it down.

Speaker 4: 00:56:37

That's hard because we need to, everyone else needs to look at this and go, how hard is this gonna be? Painful, is this gonna be for us to implement? I like the cleanliness of doing it all, right? Taproot all the things.

Speaker 8: 00:56:50

Well, I don't know if you can necessarily call it clean, because you could argue that not having to deal with this shit brings even more cleanliness.

Speaker 5: 00:57:03

Well, I mean, you're going to want to reduce the chain footprint eventually, especially like with, since a lot of the taproot rationale is to like try to compress things down to these like single signatures. Right. And

Speaker 8: 00:57:14

so... The argument of course is that unilateral closes happen much more rarely than cooperative closes. On the other hand, if you do have a unilateral close, then you probably want to make sure that you can spend as much money as possible on fixing a fee situation. So if the close itself takes up less weight, it's probably a big benefit.

Speaker 4: 00:57:40

Yeah.

Speaker 3: 00:57:40

Debate. But co-op closes are also smaller, right?

Speaker 8: 00:57:45

I'm sorry, what's smaller?

Speaker 4: 00:57:46

Oh, yeah. Everyone wants it for co-op close. That's undeniable. We definitely want taproot for co-op close, right?

Speaker 8: 00:57:53

Yeah, but that's not up

Speaker 3: 00:57:55

for debate.

Speaker 4: 00:57:56

But that's also the easy part, right? That's pretty trivial. We know how to do that.

Speaker 0: 00:58:01

Not having to remember actually state the nonce stuff. Dustin and I worked through this at the Spec Summit a few weeks ago and removing the state requirement of adding taproot nonce negotiation for the commitment transaction. It is non-trivial, right?

Speaker 1: 00:58:19

Well, so the thing is this isn't codified in the spec yet, but we're doing a thing where we don't have to remember anything because it's another shot chain. It's another shot chain. You can use that to drive the nonce. You have a counter already for the state. They're distinct messages. They never see your signature because it's constructed. You have to

Speaker 3: 00:58:34

store your counterparty's nonce, right?

Speaker 1: 00:58:38

That's, well, you already need to do that. Oh, no, no, no, no, you don't need to. Well, oh yeah, I'm sorry, you're right. So, correct, yeah. There is that per state field now, which is just that 33 by nonce. But you're already storing. To me, it's no different than the next revocation, which we store today.

Speaker 3: 00:58:57

We just store it once. Or we only store it for the latest state, right? Because you only need to sign the latest state.

Speaker 1: 00:59:02

Yeah, I mean, latest state, but I guess I was drawing similarities between basically the next revocation key that we send anyway, that you also need to store.

Speaker 0: 00:59:10

And I

Speaker 1: 00:59:10

don't know, I know people are doing like remote or like, you know, VFS things like that. I'm not sure what the implications are there, but like, you know, to me, like,

Speaker 0: 00:59:19

it doesn't, I mean, like,

Speaker 1: 00:59:19

I don't know why we should make forced closing more expensive for the new thing, and then also have two different paths for signing updates versus closing.

Speaker 3: 00:59:28

And it just feels late to do this. Not the other key, it's marked into the signature, right? Because you already have to store the signature for that, the counterparty signature for that state, you're just making the signature a little larger.

Speaker 1: 00:59:41

Yes, so for us, we basically serialize the SIG and their nonce alongside of it, right? So this is like the partial sig with nonce thing. So we store that and it is a bit more there, but you can say less on chain generally. And if people like this direction because they wanna do like an explicit threshold thing, that's something else, I guess. If the whole frost thing was too complex, something like that, that's something else and that feels like it can be done. But to me, it feels late to try to add co-op close and make that distinct here. And it's just more by it's own chain. And now you have two different

Speaker 3: 01:00:18

paths as well. That's an interesting point. It makes the frost stuff we said, Blair.

Speaker 0: 01:00:25

Is this something that you could

Speaker 1: 01:00:27

like- It feels like people were discouraged about Frost, but they haven't fully given up there. So I don't know if people, they're still investigating that. And there is just like the check, sig, add thing as well. And I think one of the things that like, because, you know, Gossip 1.75, or we're calling it like now just say it's a pub key, that means you can do whatever you want to, right? Where before it would maybe would sort of prescribe music to now you can have a script path that like has 20 signers if you want to, right? And that's not enforced on the gossip layer anymore but then you would need to define all of that, you know, for that channel type, which you can do because it's a length level thing. And you know, hey, there's gonna be more channel types in the future anyway, so.

Speaker 0: 01:01:06

Yeah. I mean, would it make sense to make this like just a different channel type then? Like the, there's like an option to do commitment transactions without the nonces. I guess then it's like a, you get like the, who's supporting it. It's probably better to have a single. That's going to make

Speaker 8: 01:01:23

it more complicated.

Speaker 5: 01:01:24

Yeah, you get that you get an n squared problem.

Speaker 1: 01:01:26

Well, yeah, I mean, if Z River wants to like, take it all the way and actually implement it, then there's that. But then the question is, do people really want to have the two versions too? Where there's some new stuff, and at least it seems like the libraries upstream, like ZP and things like that, are giving you that stuff and you can use ZKP otherwise. But generally, what we're spending time in the PR review now is basically all the on-chain stuff. The funding and the statement itself was relatively contained because it just piggybacked onto everything. And you basically encapsulated the Moosic2 stuff on the side. But I guess the thing is, until we would get farther, you can't really internalize what it's like versus this or not, right?

Speaker 8: 01:02:13

Yeah, I do want to say, though, that if people want to use a non-sluss scheme in order to be able to use frost more easily, that's actually, well, that's a disadvantage because then that leaks that you are probably interested in that because they have some different signer setup. So...

Speaker 1: 01:02:34

Right, in order to... Yeah, it's not clear that you can not leak. Yeah, so... Unless you warn everybody.

Speaker 3: 01:02:41

Right, but I think that's...

Speaker 8: 01:02:42

Yeah, so everybody has to be the same for a maximal anonymity set.

Speaker 3: 01:02:46

Right, So that would be a very strong reason to do the non-spaced version.

Speaker 8: 01:02:54

Yeah, assuming we can figure out Frost 4, but that doesn't sound amusing.

Speaker 3: 01:03:01

Right. I think that'd be a really strong argument for doing that for everyone.

Speaker 1: 01:03:06

Yeah. Doing what for everyone?

Speaker 8: 01:03:08

No analysis.

Speaker 1: 01:03:11

But like, I mean, are we over-indexing the Frost case, right? Like, are people actually ready for that on like a large scale and Robono is going to be doing it? Or like, you know, how many writers are actually going to be doing it? Like, should we really burden everything?

Speaker 3: 01:03:23

I don't think it's going to be common, but I think it will. People are more, I think, as we figured out more and more pieces to it, I think people are becoming much more ready for it.

Speaker 8: 01:03:33

Yeah, and to my knowledge, it's not

Speaker 1: 01:03:34

that you can't do it. It's just that like the existing model maybe didn't fit a hundred percent, but it's still possible if you're willing to expand your model of the single signers or whatever.

Speaker 3: 01:03:45

What do you mean? No, you need, with the current taproot thing, you need frost in music too, right?

Speaker 1: 01:03:50

Well, you know, I was talking about like the whole like three, four thing that like, it's not that like, it's not possible, it's that the parameters have changed basically, or there's some additional parameters you need to consider that maybe people hadn't really thought of in the past, which was the threshold number on the Frost level and like the fault tolerance level.

Speaker 3: 01:04:07

Yeah, yeah, yeah. But now that there's been some additional thinking there, I think it's the clarity in terms of whether this is possible is much better. I think by far the largest question is, can you do a Frost in Musig? And this question here now, or at what point would Frost in Musig be something that you could reliably do and like consider secure?

Speaker 1: 01:04:35

Ah, and you're talking about nested music with one of them being frost basically.

Speaker 3: 01:04:39

Right, because that's what you would need to do if you did not do the nonce. If you did the non-nonce version, You just need frost. And I think that's much clearer.

Speaker 1: 01:04:50

And non-nonce being basically checksick checksick, right?

Speaker 8: 01:04:54

Yeah.

Speaker 9: 01:04:54

Yeah.

Speaker 8: 01:05:01

The thing is, we have been looking into the whole nested frost thing and every time we're looking into it, there is something else that we notice and then something that we realized we had overlooked and then something where we think, oh, actually, it's not as bad as we thought it was. So it would be nice to have some sort of concreteness from the academic side of you know, Bitcoin developer community to know, OK, what is and isn't possible. Like, Are we shooting ourselves in the foot if we decide not to do the known-ons thing?

Speaker 1: 01:05:39

Well, the thing is, I feel like at the end of the day, Frost is MPC, and MPC implies sheer bit systems, and sheer systems are hard, so, try to get away from the complexity of the scheme itself.

Speaker 3: 01:05:49

Yeah, but it is from

Speaker 8: 01:05:51

simpler and PC protocols.

Speaker 3: 01:05:53

Frost itself is relatively better understood in terms of like design. There's some actual,

Speaker 1: 01:05:59

well, yeah, I mean, I mean, there's like floss, the floss, like the crypto protocol, and then Frost the stuff that implements it basically. Right? Like the wrap around, where you have to talk to

Speaker 0: 01:06:08

a network.

Speaker 3: 01:06:09

I think the implementing part is at least, I think there's some level of confidence that that's doable. The nested part is the like, we don't even know if this is possible without like adding multiple rounds and additional like massive leakage. Right, so I think that's that's the

Speaker 0: 01:06:32

you know, we are We are over time by 10 minutes. If people want to keep talking, I'm definitely down to keep chatting. But if that.

Speaker 3: 01:06:42

Rusty has been sitting here for the last 10 minutes. No,

Speaker 4: 01:06:48

no, no. Yeah. Look, I'm loving this conversation. I did want to note that we looked at nested music for the gossip stuff where you go, Oh, actually, you know, because we're signed with a taproot key, and we want to sign with two node keys. And can we do this? I probably am I can't, I'm leaning towards a hybrid at the moment where if you've got one SIG, that means, okay, I have signed the whole thing with three keys, the taproot internal key and the two node keys, and I've managed to do that. If you've got two, it means, well, one of them's just, this is the sign by the taproot key, and this is signed by the node keys. So you don't have to do nested frost if you can't do that. But if you manage to do that in future, then, because the verification side is trivial, right? Validation, signature, well, it's signed by all three. That's great. How you produce that. So we're probably going to have to do some awkward hybrid thing. They talked about half aggregation, which is much easier,

Speaker 0: 01:07:45

but

Speaker 4: 01:07:45

I'm still holding out hope that we will end up with nested Frost sig new thing that this Franken creature will come to life and we will get down to a single signature So even though it's gossip and we care about bytes I'm tempted to not go for half aggregation and go for either two sticks or one stick.

Speaker 3: 01:08:04

On this. I did go back and forth a little bit after the last meeting with, Jonas, I think, and he pointed out basically like, you don't really gain anything if we get that hybrid creature actually, because the verification time is basically the same. It's all just adding the puggy anyway. Might save a single

Speaker 4: 01:08:26

operation. It's size.

Speaker 1: 01:08:28

Yeah, it's more about the signer being able to do it in the future, right? Verifier is like more or less the same. It's like when the standard figures are out.

Speaker 3: 01:08:36

The performance of the verifier is not substantially different is the point. You just save the extra bytes of the extra signature.

Speaker 4: 01:08:43

Yep, yeah. Cutting from two signatures to one is better. Yeah, but it's gossip, right? The tighter we can make gossip, the better, always, right?

Speaker 1: 01:08:54

Yeah, and I don't think Elle's updated the PR yet, but my thing is like, she's doing what she's talking about here, as far as like letting Frost exist or nested in the future, basically, but then have the verifier be able to understand whatever. And that just like gives us time to figure it out. If we do whatever. Yeah.

Speaker 4: 01:09:11

I think that's where we ended up. But yeah, go beat up an academic and get them to implement nested frost music today.

Speaker 1: 01:09:21

Yeah, I partially implemented nested music, but this is before 1.0 and there's like another like parity factor or whatever that kind of messed it up. I probably just need to revisit it. But I mean, I maybe have to do it, but I guess the question I'm kind of like, do they think we should do it? All right, so that's the, is it possible versus, you know, is it secure? That's, that's how I see different questions.

Speaker 3: 01:09:40

Yeah. So that was not really a conclusion at all to the taproot thing. The problem is we really should decide this cause to Lala's point, it's getting late in the game. So it would be nice to have a concrete conclusion.

Speaker 1: 01:09:52

If people want to add the bit and then define it I think they can and you know that obviously requires other people to do it too.

Speaker 3: 01:10:03

I assume at this point that L&D will ship with nonces because you guys have already written the code. That is a very separate question from will others ship with the same and will I mean similar to what we ended up with anchors because people ship quick there ended up being two different variants of anger. And we're only just now getting that fixed. Right.

Speaker 4: 01:10:20

So that's one question. I need to

Speaker 1: 01:10:23

write up. Do you want me to write up the nonce thing? Because I think, you know, I think I talked about the recognition. We said, okay, well we won't prescribe it basically, but we can say people, you should have a new notch. Right. Should I write up the nonce thing and more details like frankly

Speaker 3: 01:10:36

frankly personally I was totally fine with the nonce thing until you brought up the multi-stage question and I'm like oh shit actually maybe this makes more sense

Speaker 1: 01:10:48

well just just have multiple phones right like

Speaker 3: 01:10:53

Four different lighting channels, it's fine. Yeah, I don't, I don't. Yeah, I mean, I'm okay with taking that down the road. I assume people will at least you and probably maybe even us will ship with nonces because you've already written it and are already written some stuff. But that's different from what other people implement in V1 and what goes in the bolts, right? Because at least the conversion between the two of them will be really kind of trivial. Having a feature that is supporting both is not really hard.

Speaker 1: 01:11:32

But okay, I guess is there any direct soul searching that needs to happen on this front?

Speaker 0: 01:11:39

I mean, I feel like it's like it's like core lightning hasn't implemented anything for top root yet, right? So like, as like a new implementer, it's like, okay, we want to do what we think is going to be like the best thing for the spec, right? So like, ignore, you know, we don't, we don't have the, we clearly don't have the history or any of like the code that we would have to change. It's all like greenfield to some extent, right? So like for us, it's like, okay, what is going to be, like, what do we think is, like, literally, you know, like, forgetting, you know, what shuffles have already been put in the ground, what is, like, the best implementation, when not with, like, compatibility, right? So, I'm not really sure, like, what the answer is there, right? Maybe we should have another discussion about this next meeting around it after, is it definitely over time here? And- I

Speaker 3: 01:12:33

just feel bad kicking it to the next one because then it's just going to be, well, we've already shipped the code instead of, well, we're about to ship the code.

Speaker 0: 01:12:41

Yep, that makes sense. I mean, I worked on, I definitely worked on spec stuff that had to get changed after it got shipped. I think all of us probably have. So I don't really feel that one. I mean, from a design perspective though, what are our design goals?

Speaker 1: 01:13:01

My initial goal was Moosig minimally everywhere, which is what led to State Machine and Code Close being Moosig. And that also coincided with reducing on-chain fees whenever possible. There are some cases in the new one where things end up being a script path because anchors, other things like that. But at least my initial goal was like music everywhere minimal chain footprint test stuff for btlc stuff and sort of like de-risk music stuff in general in terms of like knowing how it works and other edge cases and stuff at least But if we're changing that to support more multi-seq thresholds or something like that, then it's separate. But I guess the other thing as well is, wouldn't the whole thing around allowing arbitrary multi-seq threshold also lead into the whole mini-shotchain thing, which doesn't seem

Speaker 0: 01:13:49

to have been

Speaker 1: 01:13:50

figured out

Speaker 0: 01:13:50

fully yet?

Speaker 3: 01:13:51

I think that has been figured out fully. I'm sorry.

Speaker 4: 01:13:54

I don't

Speaker 3: 01:13:54

know if I posted it on IRC, but we did get a general solution. Did you

Speaker 4: 01:13:59

get all the numbers? Like, how many do we need? Is eight the right number? Okay.

Speaker 3: 01:14:03

I think 10 is the right number because if you want to do five of seven, it blows up to huge, but 10 gets you three of five.

Speaker 0: 01:14:09

Okay.

Speaker 1: 01:14:11

So that's everyone's always send and process 10 Shawchain things.

Speaker 3: 01:14:16

Basically. Sure.

Speaker 1: 01:14:21

I guess one part of me is like, what, you know, it feels like we're really impacting the protocol for what seems to be a rare case that people like, but it's unclear how widespread it will be. I mean, Because are you really going to have, you know, five different nodes? Or where are they? Like latency stuff? Like... Yeah.

Speaker 8: 01:14:38

Well, if it's not going to be supported, it's obviously not going to be widespread at all.

Speaker 1: 01:14:43

Well, but I just mean the burden of everyone having to always do the 10, right? If you want to have an empty set hand wave.

Speaker 4: 01:14:49

It's pretty easy. I mean, Modulo haven't actually implemented it yet, but I mean, it's pretty easy to implement. Like it's going to be trivial. We'll probably just by default tweak like the short chain thing to get nine more secrets out of it and then just

Speaker 1: 01:15:09

yeah

Speaker 0: 01:15:13

yeah yeah I just posted a quick question in the chat about like how much does ease of ELS support way and do they like the design of the protocol? I don't know how easy to shotchain stuff really easy to implement or add to the DLS stuff, but maybe something

Speaker 4: 01:15:29

that I think will be trivial for them. I mean, it's pretty efficient and they will do, at least if they're doing single signer and they're not trying to do this advanced, we've actually got multiple signers, doing multi-share chain is really trivial.

Speaker 1: 01:15:46

Yeah, cause also I'm not sure if VLS has like any Moosic2 partial SIG API stuff at all, which they would need, right? So I think that's like a whole nother thing they need to figure out in their model on top of, you know, either way, potentially, you know, even if the corp.closeverse is not. I'm looking at, they have like a state struct that I guess would have this too. But yeah, I guess we can ask them how they thought about that music too in general.

Speaker 4: 01:16:13

Yeah, I don't think it's going to make a big difference for them, to be honest. Oh, maybe they care about nonces.

Speaker 1: 01:16:24

Yeah, it's a question of, like, they want to do the new nonce thing or not. They do have that extra bit of state they need to store, which is alongside the signature really. And they're doing that verification, but I guess we've not some about it, but, but okay. It seems, I guess, like at least the social thing stuff here is like, see what VLS thinks and then, you know, core lightning, like size up the impact or, or, or something. I

Speaker 3: 01:16:49

mean, we get

Speaker 4: 01:16:50

to Matt.

Speaker 3: 01:16:53

Oh gosh. So I'll do,

Speaker 4: 01:16:55

I'll do multi-shot chain. How's that?

Speaker 3: 01:16:58

I can ask the VLS folks to join next week and think about this beforehand if that's helpful.

Speaker 0: 01:17:07

Yeah. Maybe get

Speaker 4: 01:17:07

them to join in two weeks. That way we'll be here.

Speaker 3: 01:17:12

Yeah. I won't be. I'm off next Monday too. So I also won't be here, but.

Speaker 1: 01:17:24

Cool, okay, all right, so we at least have cell search and action items, and then them being there as well.

Speaker 3: 01:17:32

Okay, I will-

Speaker 1: 01:17:32

And you know, I'll write the thingy up, just at the end and add it to the spec. Maybe it's clearer when it's just there, and it should be there anyway. We can just say, hey, this is an optional thing if you want to do this. Otherwise, the nonce should be random. Figure that out.

Speaker 3: 01:17:48

Yeah.

Speaker 1: 01:17:50

Cool. OK.

Speaker 0: 01:17:51

Yeah. I

Speaker 1: 01:17:52

mean, and it can be pretty short as well, because like, at least we're doing this. I mean, I guess when people want me to prescribe the shot chain thing we're doing right now, or just say, you can do a counter thing.

Speaker 4: 01:18:03

Yeah, no, might as well describe it. Here's a scheme because that's always like, it saves me thinking, right?

Speaker 0: 01:18:09

The Shaw chain thing is more on the, sorry.

Speaker 1: 01:18:15

There's two Shaw chain things. One is the 10 Shaw chain. The other is another Shaw chain that generates your nonce.

Speaker 0: 01:18:21

Shaw chain is on the, guys, Shaw chain is on the side of determining. Hang on. Shaw chain is on the side

Speaker 3: 01:18:29

of the.

Speaker 1: 01:18:30

The dog, the dog's like the nonce. I don't know.

Speaker 0: 01:18:33

I'm just like moving my crown, it's very disturbing. The Shaw chain side is on the generation stuff, not the storage side, right? So it's more like, I mean, I feel like whenever we're looking at those, and it's been a few weeks, the bigger thing wasn't on picking your nonce. Picking a nonce to send is on the short chain side, right? It's more the needing to remember and store and keep these extra stuff around. You either have to store the nonce from your partner now or the... Well, so...

Speaker 4: 01:19:11

Well, Rosebeth was saying, I think that the requirements for nonce storage are the same as requirements for signature storage. So if you treat it as like it's a partial signature, which is kind of what you do now, you keep their signature, you keep their signature in the nonce so that you can make your signature.

Speaker 1: 01:19:27

Correct, right? And so- It

Speaker 4: 01:19:29

doesn't seem like a stretch.

Speaker 1: 01:19:31

Yeah, yeah. Otherwise, if you don't do counter-based, you would need to remember the non-state you sent so you can force close, right? So now like your minimal force close state is their signature and that as well. You can serialize it and that's fine. But okay, but I think it just tells me I can just add some more section in the spec around just kind of like the requirements and if that's not clear, and then also like specify the scheme and just make it clear like what you need to store basically and what you can get away from not storing and so forth. But yeah, in the minimal sense, it's no different than today. You just have their nonce and a signature alongside of it, which you need to do the combined thing anyway.

Speaker 0: 01:20:05

Yeah. OK. Yeah. That sounds good.

Speaker 1: 01:20:07

OK. Cool. All right. I got to hop off. But a productive meeting. See you all on my interesting stuff. Bye.

Speaker 8: 01:20:16

Yeah. See you.

Speaker 1: 01:20:17

Thanks so much, Waldo.

Speaker 8: 01:20:17

That was really helpful.

Speaker 3: 01:20:19

Cheers. Thanks, everyone. Bye.
