---
title: Lightning Specification Meeting
transcript_by: carlaKC via TBTBTC v1.0.0
tags: ['lightning']
date: 2023-08-28
---

Speaker 0: 00:00:00

Any of the, I don't think I've seen any discussion happening on any of the PRs and they all last from the last time. So I don't know if we, I don't think we should go and have them in order, except maybe the first one that we may want to just finalize and get something into the spec to say that it should be 2016 everywhere. But as Rusty was saying, can probably make it a one-liner and it would be easier. Please. Okay, so let's just make that feedback and wait for Antoine to transform this into a one-liner. And one other thing that I've seen a lot of discussions on is related to simplified commitment. We had a bug, there was an issue, I'm going to link that issue right now for a force close that happened between an Eclair node and an LND node but then also happened between two LND nodes and this is a case where actually without simplified commitment we don't have a choice And because people both sides can asynchronously be adding HTLCs, we can end up just getting into the remote reserve and having to force close because the reserve is not met. And there's just no way to avoid that situation with current protocols. So maybe that's a good argument for working on a simplified commitments at some point.

Speaker 1: 00:01:23

Yes, it's definitely on my to-do list for this next release, which is three months away. We've just done a release, so now I can't use that as an excuse anymore. And option simplified commitments is on my list to do and then scratch out an implementation. We have one that Greg Sanders did because he did it for L2, but we have to, It's slightly more complicated for the current LN penalty. So I plan on revisiting that in the next three months.

Speaker 0: 00:01:55

Okay. Yeah, I think it's really worth it because we're starting to see all those issues with people experimenting with sending a lot of HTLC that frequent weights, right? We are hitting those edge cases and we want to provide commitment. There's just no way to avoid it. And having false closes that we cannot avoid are really, is really annoying. So, shall we very just quickly go down the list in order and see if we have anything to say on it, or otherwise we just move to something else. So do we have anything new on the simple close? On my side, I haven't had time to prototype anything yet. So I think it's more looking, waiting for implementation.

Speaker 1: 00:02:45

Yeah, and we did, I have to rewrite it because we did say that whoever's got the most funds will have to provide an output was the simplified version. So we'll, I'll switch to that. And we just accept that if your channel is really tiny and you can't afford to close, you can't afford to close, right?

Speaker 2: 00:03:02

Yeah.

Speaker 0: 00:03:04

OK, so just needs a small change on the spec, and then people starting to actually work on it. Maybe is there someone from LND who started working on that in the context of Taproot? Since the first Taproot PR was merged to master on LND. Is there some followup work that is being worked on on the closing side? Or is there someone from LND?

Speaker 2: 00:03:27

No progress right now on that front list.

Speaker 1: 00:03:30

Okay. Yeah, I know Rospiff was pretty keen to get this, So I expect it'll happen pretty soon.

Speaker 0: 00:03:38

All right. So then on the spec cleanup, yeah, add to my to-do list to actually make, at least make those features mandatory in Eclair. I think we should all do the same, but apart from that, nothing new on my side.

Speaker 1: 00:04:19

So, there is an issue that came up with splicing and gossip, which I was just reminded by the fact T-Best made a comment in the offer PR, which is kind of, It was a little meta on short channel ID usage. So we have this issue where if you splice your channel, we have this bridge like this, this 12 block bridge where if you know about a channel and it closes, you give it 12 blocks and consider it still to be live. Now, that has some weird cases. It means that during that time, you probably don't propagate any updates for that channel. You will annoy other implementations if they're completely new on the network. You'll be talking about a closed UTXO and they will be like, I don't know what the hell you're talking about. We stopped gossiping about that because I know t-best complained to Claire, said that we were gossiping about dead channels all the time. So, but it also means if that's your only channel and you've just spliced it, you can't propagate your node announcement now for like six blocks. So while it kind of works almost, it's not a great solution. We had proposed previously that you have this magical update that says, hey, I'm splicing, there's a thing happening. And somehow that lets you change the rules. Like you explicitly mark something. But it still doesn't help the case with new nodes coming on the network. How do you provide a splice in progress? If they've got a simple lookup and they say, well, this UTXO doesn't exist, it's not clear to me how we solve that problem.

Speaker 3: 00:06:08

Is it worth solving?

Speaker 1: 00:06:11

That's a good question.

Speaker 0: 00:06:14

Couldn't we just have a new, just emit a new channel update? We're still using the first SCID that has been spent, but we had a TLV with the current SCID that is unspent. Just say, OK, you can look at the DCUTXO is actually unspent, and it is actually a child of the one, the main one in the channel update.

Speaker 3: 00:06:42

Or new nodes can just miss a single channel until they restart.

Speaker 1: 00:06:47

That's possible. I mean, the question is, do we allow the node announcement in the case where the only channel you've got seems to be closed and we're like, we're gonna let you do this for a little bit.

Speaker 3: 00:06:57

Yeah, I mean, I would vote Yes, just, you know.

Speaker 1: 00:07:02

Similarly, channel updates, right? So can you change your fees while you're splicing? And I would think the answer is probably yes, you want that. It does mean some noise though, of course, for new nodes who will be confused by if I'm talking about this thing that doesn't exist from there.

Speaker 3: 00:07:17

Yeah, but they'll just drop it. I mean, they might send a warning message, but maybe they should read one of those warnings or something, I don't know, whatever.

Speaker 1: 00:07:24

Well, you probably shouldn't send a warning message because the other node could be a block behind anyway. I mean, you always get that case where they think it's still live and you've seen a new block they haven't. So six blocks is a little bit pushing it, but still. Okay. Just that we should, I just wanted to bring it up because it's something that we should make explicit. Like, do you still propagate gossip for those? I think the answer should be yes. And maybe later we will. I mean, explorers are going to have to figure this shit out at some point. Because I think at the moment, their marking channels close as soon as they close. So the channels vanish, and then they reappear again. Might be nice to have a hint that this is a splice in progress, but frankly, them delaying 12 blocks is probably fine too. Cool, I just wanted to bring it up. But if everyone's happy to continue down the same path for the moment, then I will just try to make sure that we do propagate on those.

Speaker 3: 00:08:28

We can add a hint, but I would vote not having to add any logic around the hint. Like if we want to add a hint for block explorers or people to log or whatever, fine, whatever. But I would vote not having to write any code that deals with the hint aside from the occasional log.

Speaker 1: 00:08:49

Okay, cool. Well, we'll leave it now and we can do something later, but yeah, I will restore our propagation. I'm reworking all this code at the moment, so it's a good time for me to look at whether we propagate these or not. But yeah, it's particularly annoying for the case of a single channel where your node vanishes while you're splicing. It seems a bit unfortunate.

Speaker 0: 00:09:11

Yeah, we haven't worked on the gossip part of splicing. We've just focused on doing it for private channels for now, which was simpler, but we should start working on the public part and how it links to Gossip. So we should probably have feedback and ideas once we start working on that.

Speaker 1: 00:09:27

Yeah, cool.

Speaker 4: 00:09:33

I hope there's not like a weird case with a splice that never confirms here.

Speaker 0: 00:09:39

No, because it never confirms the previous channel.

Speaker 1: 00:09:44

Yeah, If you haven't confirmed yet, you can't even tell, right? So your individual channel is still fine. Everyone's happy with your gossip. So it's actually pretty neat from that point of view.

Speaker 0: 00:10:03

Any feedback on the spec cleanup or should we just start by just... In your latest PR, in your latest release in C Lightning, did you made all those four features mandatory by default?

Speaker 1: 00:10:14

No, it was too late, but that's one of the first batches that's gonna go into the new release and see what happens.

Speaker 0: 00:10:20

Okay, we'll do the same.

Speaker 1: 00:10:22

And even better, I'm gonna rip out the code that tests for it, it's gonna be fantastic, so nice.

Speaker 0: 00:10:31

All right, so next step is the SCIDs in BlindedPath. I haven't thought about it more since last time. Okay, is there a prototype implementation?

Speaker 1: 00:10:48

No, I haven't implemented this yet either.

Speaker 0: 00:10:51

And Matt or Jeff on the LDK side?

Speaker 5: 00:10:59

No, we've

Speaker 0: 00:10:59

not implemented it. Okay. Yeah, I guess we should just wait then for people to implement it and see if it just works out Okay, or if we discover some things that are annoying

Speaker 3: 00:11:12

Well, I mean it might end up being annoying for us That's okay

Speaker 0: 00:11:18

Why?

Speaker 3: 00:11:20

Well, the Onion Messenger is wholly unrelated to the channel logic. It doesn't currently have any references to it. Now it needs some pseudo references to it indirectly for paying multiple invoices. And so we can maybe reuse that interface, but currently there's no relation.

Speaker 0: 00:11:42

Yeah, it's probably good to get a name for us as well.

Speaker 1: 00:11:46

Yeah, we already have that crossover in routing, right? Where you nominally have no real connection to your short channel IDs that you're gossiping. But now you have to. I don't, I don't hugely mind it.

Speaker 3: 00:12:03

Yeah, I mean our routing system is obviously also separate from our... Oh, you mean routing for on-EMS use, yeah.

Speaker 1: 00:12:10

Yeah, exactly, the same issue, right? In theory, there's no real reason to have the short channel ID except that...

Speaker 0: 00:12:25

Yeah, it just basically adds one lookup so it's a bit more expensive to relay messages.

Speaker 1: 00:12:32

The problem is do we need to... Yeah, I know. The argument for this PR was that it is worth it to reproduce sizes. And if it is, then let's do it.

Speaker 3: 00:12:44

Yeah, I think it's definitely clearly worth it on the forwarding parts that like introduction parts more annoying. But actually, the introduction part might be easier in the code. We'll figure it out when we get there.

Speaker 6: 00:12:56

Yeah, for routing, though, it's I mean, not that it's restricted now, but it's really only important when you're forming invoice requests. This ideally invoices wouldn't have these short challenges they wouldn't need them at all. You know, wire, the point of having this is for QR codes. But we're not enforcing that

Speaker 5: 00:13:18

in this method.

Speaker 1: 00:13:19

Yeah. I mean, yeah, they are transient identifiers. And that means, you know, you get to keep both pieces. And of course, you know, you could lose these things at any time. But there are cases where it might make sense. So the latest version is using the encode alternative hack where we use OO and O1. I have a love hate relationship with that idea. I know I came up with it, but I'm still, I don't know. Okay, if nobody thinks of anything better, then sure, let's do that. Cool.

Speaker 6: 00:13:57

Yeah, it makes the spec change pretty much trivial, which I kinda like. Otherwise you're adding new types for path, like an effort, TLB record for a

Speaker 5: 00:14:09

different type of thing.

Speaker 1: 00:14:10

Exactly. Now, If we were to introduce such a thing, oh, we've already got separate fields in onion messages. We could go back later if you wanted to and unify those fields and use the pub key, but then put the SCID in there if you wanted to. I don't know if it's worth it. So fine. Okay.

Speaker 6: 00:14:32

I was about to say it's also annoying when you have to, if you get like, I don't know whether we would have, whether we would want to support both types of paths and offer for instance, or it was just one, just adds more logic.

Speaker 0: 00:14:47

Yeah.

Speaker 1: 00:14:49

Cool. OK. OK, so other than the fact that I hate the fact that you renumbered things gratuitously to try to keep

Speaker 6: 00:15:02

the deal. It's no longer a problem, so we got rid of that.

Speaker 1: 00:15:07

Yeah, cool. So I might fold this into my PR, so it's all in one place. The office PR. Yeah. OK, cool. Everyone seems in agreement. Easy.

Speaker 0: 00:15:26

Yeah, then on the other side, I'm preparing the step conf net next week, and I'm going to do a workshop about writing plugins for Eclair and we're going to write a Bolt12 plugin so that people can accept tips using Bolt12. So I've just finished testing it and it's really, really easy to write. So I hope people will start playing around with it and we get to merge that soon.

Speaker 1: 00:15:58

And I am going to create another PR because people love these things that reintroduces this recurring payment thing so that we can discuss that thing that we pointed out. But it will keep it as a separate PR as an extension. Because I think it's an interesting idea. And there are complexities in there. I mean, it's definitely something that we want. I mean, it's a very clear use case that everyone loves. But I have very opinionated ways on the way you have to do it. Because people have proposed really dumb ways where you'll call the server and ask, do I owe you a payment? Or they'll call you and ask for another payment and stupid things. So it's worth having a discussion once we get to that point. So I will reintroduce that, which basically it was an old diff that I have to now rebase. Ooh, Val has some news.

Speaker 7: 00:16:46

Yeah, just chugging along, merged several last week, but still some to go. So we're pretty focused on it. So yay.

Speaker 3: 00:16:55

We're making good progress. We did, there was a bunch of conversation in the Bolt12 discord around the spec for how you build the fees and the HTLC minimums, which I found to be very confusing. And then there was more conversation and something, something, I think that's our next thing that we need to figure out. So I would appreciate some help there, but I know people are busy.

Speaker 0: 00:17:20

Yeah, I should spend some time on that document again to try to clarify that, but maybe after the taproom. Okay, then quiescence and splicing. I'm not sure there's anything new, but we were discovering more and more edge cases where handling the reserve after a splice is really annoying when two people splice and you have to compute the previous reserve, but apart from that, it should eventually be working great.

Speaker 1: 00:18:11

Yeah, there was always the problem that with the 1% fixed reserve, if I splice in some massive amount into your channel, you can't spend, we can't, basically the channel's useless until like if I, normally if I put like a hundred times the existing amount in a channel with a 1% reserve, what happens? Like we can't use the channel now?

Speaker 0: 00:18:32

We had a discussion on that in a PR that I created and then closed with Matt and Al and the other Matt Morehouse. And the main takeaway is that whenever you splice, if a new reserve is not met, it's as if it was a new channel, actually. So you should just enforce the previous reserve and start enforcing the new reserve only once it gets met.

Speaker 1: 00:19:01

Fair.

Speaker 3: 00:19:02

Presumably not allow any channels that make it worse. Or any HTLCs which make it worse, right?

Speaker 0: 00:19:15

Make it worse in what way? As long as it's still...

Speaker 3: 00:19:18

You have to make progress towards the new reserve if you have any issue going the wrong direction Which is still within the old reserve, but doesn't make progress towards the new reserve. Shouldn't you reject it?

Speaker 0: 00:19:30

But that could be an issue when the other side adds a hundred times the price of a channel. You may still have an untrivial amount of money in that channel that you want to send out, but the other side is kind of forcing on you that the channel gets much bigger. So are you then stuck until they push some funds on your side? Or should you reject that splice?

Speaker 3: 00:19:54

You should reject that splice if you don't want, I mean, or you don't change the channel reserve, right?

Speaker 0: 00:20:03

Yeah, in a way, They are adding a lot of incoming liquidity to you which is nice but that means you need to then wait for them to use that liquidity before you can start using the channel again in your direction.

Speaker 1: 00:20:16

Once the splice is locked in you will fall into the code where you have to head towards meeting your reserve if you haven't already. The question is, do you do that once you've agreed to the splice or not? We should get rid of reserve.

Speaker 0: 00:20:39

Is that what you do even for normal open? Well, I mean, if I open a channel to you with a push msat, so that you are initially under the reserve requirement, are you allowed to send that push msat out or do you block that until I think because in Eclair we allow you to as long as you haven't met the reserve once We kind of let you do whatever you want.

Speaker 1: 00:21:03

Oh, I'm pretty sure we make you, you can only go towards the reserve. If you're under it, you can't get further away from the reserve. I don't think I'd have to check the code though, but it only happens with push M sat and it doesn't really happen. Yeah.

Speaker 3: 00:21:17

Yeah. No one uses that.

Speaker 2: 00:21:21

But what

Speaker 3: 00:21:21

about if you send one HTLC and then can they send it back? I don't know.

Speaker 0: 00:21:30

Yeah. Reserve is annoying. Really annoying. Yeah. Anything else on splicing? Any new progress on either that or cohesence?

Speaker 4: 00:21:48

I was just curious how Questions of the Essence is going for you over there.

Speaker 0: 00:21:53

Oh, Cohesence, we finished implementing Cohesence and it's even on master on Eclair and Richard wanted to try it against the Lightning to see if the Cohesence part works. We know that the splicing part is not gonna work because we don't use exactly the same TLVs in commit-sig, but all the quiescence part, I guess, should be working. And Richard will try that, and we'll try to do cross-compat tests on that next week, this week or next week. So we should have feedback on that one soon.

Speaker 4: 00:22:20

Sweet. Yeah, I think it's one of those things that seems really simple, and the corner cases kind

Speaker 5: 00:22:25

of creep up on you.

Speaker 0: 00:22:27

Yeah, exactly. So we'll see what we find. I think initially we think that, yeah, cross-compat is going to be easy. Everything is just going to work out great. And then the real world happens and we find a lot of issues. We'll see.

Speaker 1: 00:22:43

Speaking of splicing though, we should mention that T-Best and I had this communication about feature bits. So because we've rolled out RC1 and had experimental splicing as an option, and splicing is like bits 62 and 63, T-Best pointed out that until the spec is finalized and everyone's happy with interop, we probably shouldn't use the real feature bits. So we're advertising if people turn experimental splicing on in core lightning, they get

Speaker 0: 00:23:10

163.

Speaker 1: 00:23:11

So we decided to add 100 to the bits. And I will document that convention, I think. And we should carry it forward. So, you know, in the PR, you put, hey, we're going to reserve this bit. That's fine. But until it's actually finalized and you've done interop testing, you should probably add

Speaker 0: 00:23:27

100

Speaker 1: 00:23:29

and advertise like a shadow feature bit. And then, of course, in transition, if it's ratified with no changes, then you can just accept both features for some transition, and it will work fine. But it does mean we don't have this annoying case that we had with dual funding, where the spec changed, but our implementation still advertised the real one, and you get, if you're perfectly spec compliant, you don't actually interrupt with everyone else who's also advertising the bit. And then you have all these debugging pain. We always hold on, that's an old core lightning node. That's why it's not working. So just going forward, we should probably adopt that rough convention that we actually advertise like on the experimental, like a plus 100 for a while. And by

Speaker 0: 00:24:12

the way, what, what do you do for dual funding in your latest release? Because I think that now most of the messages do follow the spec and we have internal testing on that between AKL and CLN, but there's still the channel reestablished part that hasn't been fully implemented in CLN and is not yet tested. So I'm not sure how that would be in practice.

Speaker 8: 00:24:36

Sorry, the question is about backwards compatibility or just the progress on...

Speaker 0: 00:24:41

In the latest release of CLN, what is going to happen for the potential incompatibilities that channel reestablish, we will just build that channel?

Speaker 8: 00:24:51

That's a good question. I'm not sure, I'd have to check. I'm in progress of implementing it, so that would make it easier to test, because I'll have one. I will look into this this week. This is a good question.

Speaker 1: 00:25:06

So we have a point release coming up because Mac OS. Anyway, so I'm holding that back. And because although we don't generally do like changes like this in a point release, because it's experimental, whatever. If Lisa gets a compact change, and we completely break or completely fix whatever the euphemism is, dual funding, that's allowed to go in a point release. So we could release a point for this. Certainly, if like you reach an interrupt milestone with Eclair, that would be a good reason to put it in. Even if it breaks existing core lightning, I'll just redirect all the bug reports to you.

Speaker 8: 00:25:42

Great. That sounds good. The status on that is that the change has been implemented. I just need to update. It changes some of the tests. So I just need to fix the test stuff. So there's a good chance that we would have that ready to go this week? So I'll try and move that up on my to-do list.

Speaker 0: 00:26:00

Perfect. Nice. Cross-compact test during Tapcon and we can release dual funding in Tapcon.

Speaker 4: 00:26:06

Hey, there we go.

Speaker 0: 00:26:07

Yeah, yeah. Nice. To be honest, we'll only have an impact. It's really the only thing that it fixes is people disconnecting after exchanging commit SIG but not TX SIG on the dual funding channels. So in practice, it shouldn't happen much. So even if we break that or think that, it should be okay to release in my opinion.

Speaker 1: 00:26:30

Yeah. The one thing I like about dual funding is however bad it is, if you get through the funding stage You're pretty much done, right? You've got a normal channel at the end. So that's nice There is one case So we I recently revisited our logic if Your channel gets reorg'd out after it's supposed to be all confirmed and you're locked in. What do you do? And I changed the behavior to force close the channel unless we were the funder, in which case we don't care. But if in the dual funding case, you do care, if they provided any inputs and you didn't trust them to do zero conf anyway, then at that point you should probably freak out if it gets re-org'd. And we don't actually track whether it was originally a dual funding. We track whether we put all the funds in, but that's technically not sufficient because they could have put funds through the transaction, not contributed anything to the channel, and you still can't trust it. So There is a really mild corner case here where you suddenly care whether it was dual funding, but that's only if it reorgs after your max confirms, in which case you're so screwed, it probably doesn't matter. So yeah.

Speaker 2: 00:27:44

All right.

Speaker 0: 00:27:52

Next up is Taproot. Is there anything new on Taproot? I've seen that a big PR was merged on LNG. Oh, there's a question back there.

Speaker 2: 00:28:01

Oh, there's

Speaker 0: 00:28:02

a question about reorg.

Speaker 1: 00:28:08

So yeah, this is a good question. It depends. If your peer is trying to screw you at this point, you're in trouble. If it's just a normal reorg and it just bounces out and bounces back in again, then you're probably okay. Either way, our answer is usually just force close if we're in trouble. Force close may push the transaction back in because your closed transaction may child pays for parent. There's no good answers at this point. In our case, if we trusted them to do zero-conf in the first place, we do not get upset and close the channel if it gets reordered out. But yeah, there's really no good solution. And it's such a corner case that you don't spend too much time thinking about. So the answer was we tried to force close it. But at least that will stop us from making things worse by using the channel at this point. That was my theory.

Speaker 2: 00:29:01

All right, at

Speaker 1: 00:29:02

least we'll shut the channel down and we won't send any more HTLCs. Yeah, note that our current implementation does not do this and we'll just continue to, It'll only get upset when the channel gets re-logged back in. So if it gets out, it will just not log anything and keep using the channel.

Speaker 2: 00:29:30

All

Speaker 0: 00:29:36

right, then taproot stuff now. There's a big PR has been merged on the LND side on master. I don't know if compact tests have been done with LDK. Does anyone have news on that?

Speaker 2: 00:29:49

We've had, we've merged a PR, have a follow up PR up in LDK, but we haven't looked at the L1DPR.

Speaker 0: 00:30:02

Okay. And do you have any, done any interop test between LND and LDK Or do you have any idea whether that works or doesn't?

Speaker 2: 00:30:12

No, we haven't done interrupt testing with LND yet.

Speaker 0: 00:30:16

Okay. And so for now, it looks like we're still using music to even for the commitment transactions.

Speaker 2: 00:30:23

Yes. Yes. We're using music to for unilateral, unilateral closest. Yes.

Speaker 1: 00:30:34

Do we have anything, any progress on Gossip? Type of Gossip?

Speaker 2: 00:30:42

Nothing yet, Rusty. We're hoping to make progress in the coming weeks. Oh, the

Speaker 1: 00:30:47

longer it takes you, the further I can push it back on my own to-do list. So I'm not pushing. I'm just asking.

Speaker 0: 00:30:54

Sure. All right, then it's attributable errors. I haven't followed up on the implementation PRs. I think we're at the stage where we're waiting for just Intel testing and last reviews. And everything else is just still, people are still working on everything. So anything, any other topic people want to discuss or anything else people have seen or been working on that's interesting to share? It's August, nobody's been working.

Speaker 1: 00:31:51

Yeah, Ziki, go for it.

Speaker 0: 00:31:56

Do we need to do something to accept it?

Speaker 1: 00:32:00

I don't think so.

Speaker 0: 00:32:01

Oh, okay. You seem to still be mute.

Speaker 2: 00:32:13

I still have you.

Speaker 1: 00:32:17

Nope. I

Speaker 4: 00:32:21

have a thing I could add while he's getting ready, which is not really a spec thing, but Lisa, we're working through how you do cross-channel splices moving from one channel to another. And it ends up interacting with the signing order stuff a lot and just gets really complicated. Just something to think about.

Speaker 0: 00:32:42

What do you mean? Many people trying to batch multiple splices across channels?

Speaker 4: 00:32:47

Oh, like just a simple case. If I have two channels on my own node, I want to move from one to the other one. My signing order with those channel peers affects the signing order of passing PSPs around. It's not really a spec thing, but I just thought it was interesting. And it's actually more complicated than I realized. And I don't think it'll mean any changes to TX signature ordering, but I don't know. It's interesting.

Speaker 0: 00:33:09

Yeah, I think we had at some point a very long discussion about that. And the ordering we chose guaranteed, we verified that it guaranteed that there could be no deadlock. So, but it doesn't mean that the implementation is simple. It's a mess, but at least in theory, there's no deadlocks.

Speaker 4: 00:33:33

Wait, are we doing it in the same way? We did end up on the same thing, right? Did we? I forget now.

Speaker 0: 00:33:40

Yeah, I think so. I think it's the one who contributes the most to the transaction, not actually the funding amount, but just the number of inputs, amount of inputs. And if there's a tie, then it's the lowest pubkey that signed first.

Speaker 4: 00:33:56

Yeah lowest pubkey of the original channel or yeah the original channel right?

Speaker 0: 00:34:02

Yeah. No. Oh no the current one I'd say. Oh good question.

Speaker 4: 00:34:09

Hopefully you wrote this down somewhere.

Speaker 0: 00:34:11

No, I think we said node ID.

Speaker 1: 00:34:13

Yeah, lowest node ID usually.

Speaker 4: 00:34:15

Yeah, node ID, that sounds right.

Speaker 0: 00:34:24

Yeah, we do node ID in the account.

Speaker 1: 00:34:37

Well, it seems like Ziggy isn't coming back.

Speaker 0: 00:34:40

Yeah, it's the usual reboot the whole PC to fix the issue. Hello. Hey, we can hear you.

Speaker 9: 00:35:24

Cool. Was somebody else talking or can I pose my question?

Speaker 0: 00:35:30

Go for it.

Speaker 9: 00:35:31

I was wondering whether we are planning in the lightning spec to Implement something that we can fail HTLC's or something like this not that can the current way where we force the other person to accept an HTLC and we cannot fail it back. It's like UDP mostly, whether we plan to do something else.

Speaker 0: 00:35:55

Yes, that's exactly something that we cannot do right now with the current protocol, but the simplified commitment change that I linked into the issue will enable us to do, I think, Rosebeef called that an ad, an HTLC, where the other guy says update ad HTLC, and you instantly say, oh no, I don't want that one, don't even bother try signing it, let's just remove it right now.

Speaker 1: 00:36:19

Yeah, but you can also fail, but they have to send both signatures. So they have to send, here's this commitment signature if you fail the HTLCs. And then the question is, do you have to fail all of the add ones at once? And I think the answer is yes, because otherwise you have to send a combinatorial, you know, number of signatures. So here's if you're going to fail things. And here's if you're going to accept things. So you have to do send both signatures across. So there are a few twists in here. But yeah, it becomes a much easier to think about with option simplified commitment.

Speaker 0: 00:36:48

Okay, cool.

Speaker 1: 00:36:49

Yeah, definitely something we want, because it simplifies your protocol a great deal, in that you no longer have to specify what the other side is not allowed to send you because you can it can send you anything, you could send me things that go outside the balance or whatever, and I can just reject them. And I'm, because at the moment we can't obviously do that because I would have to hold that state for a while. Similarly, with like fee changes and things, you would have a neat mechanism to reject them. So yeah, it's an obvious hole in the protocol at the moment, but definitely something we want to fix.

Speaker 9: 00:37:25

And I had another question related to the fee negotiation for static remote key channels like CLN was already carving out some exceptions because there were some negotiation problems. The spec just states have a reasonable amount, a reasonable range of fee accepted. I was wondering whether CLN is going that route to accept these things or will it still be there in the future?

Speaker 1: 00:38:01

Sorry, we do accept a reasonable range. The thing is that with anchor outputs, which is currently experimental in CLN, but will ideally be enabled, since we haven't found any problems, since it'll be enabled on the next release in three months' time, then generally fees are lower. So we just don't get fee disagreements anywhere as much as we do at the moment. So without anchors, you have to be fairly strict about anchors do not reduce it completely. Don't remove your requirement to agree on fees completely. We're hoping for TX relay magic and things like that that will allow us. But for the moment, it's a significant practical difference that there will be less fee agreements. We're already pretty damn wide in the range of fees that we accept. We don't accept things that won't relay. And that's kind of, I refuse to do that without some explicit user interaction, right? What happens is if, particularly with LND, if LND gets into its head that a fair fee rate is like the minimum fee rate, and it's not on our end, it will never change its mind. It will continue to retransmit that. It'll immediately, basically it will not change fee rate. Every time it connects, it'll try the same fee rate, even if it now no longer considers it to be a valid fee rate. So it will retransmit. So that's why we added in this latest release, an option to ignore fee rate, like allow any fees on a specific channel. So you can basically let it get unstuck. But there's a danger. If you accept a fee rate change that will not relay from someone, you're screwed. And people have said, oh, but you know, this fee they've offered is slightly below what you allow. And it's like, well, that's always possible. It's always true. So the real answer to this is anchor outputs. And the real, real answer to it is better transaction relay so that we can basically go zero fee. And everyone can agree on zero. And we can remove that whole part of the spec and all that pain. So yeah, lobby your Bitcoin Core representative.

Speaker 9: 00:40:09

Okay, thanks, sounds reasonable.

Speaker 3: 00:40:17

Rusty, your release notes said something about better pay plugin, something, something, smarter routing. Are you now tracking history of failures? And if so, what scoring algorithm are you using for selecting?

Speaker 1: 00:40:38

Yeah, so Christian has been looking at the green light stuff. So obviously we can see people's payments at this point. And just we were doing some dumb stuff. We were pre-splitting, but above a certain amount, we just went, we automatically pre-split before we even tried to send a payment. It turns out that that does not work very well. That was actually increasing our failure rates because at some point you start hitting HTLC number limits. So we eliminated that. There were just some dumb bugs, where especially where we had an alias channel, we wouldn't consider if we had a if we had a zero-conf channel, we didn't properly consider it in routing and things like that. They're just mainly it was bugs. Our real hope is that the Renee pay plugin, which is way experimental at the moment tends to crash, get upset. And I'm hoping that Eduardo, who wrote the min cost flow, because it's in the main cost flow part, it gets it hits an assertion. It's like, hold on, these numbers don't work. Like, well, how did we get here? So there's some fun debugging to go, but our hope is that we'll end up doing the min-cost flow approach, and we'll end up with something that is much nicer than what we have now, which is Dijkstra bolted on something, HandWave, added some heuristics. So there are incremental improvements. But I'm really hoping that next release will have something that doesn't mean cost flow and we get a decent idea of what's happening on the network.

Speaker 6: 00:42:01

Do you

Speaker 1: 00:42:04

We don't even remember between payments at the moment. RenePay actually does keep history of stuff. It's a very low bar at the moment. It's pretty easy to improve. But we're hoping to jump right up with a complete rewrite.

Speaker 2: 00:42:18

But we're hoping to like jump right

Speaker 3: 00:42:18

up with or you know within complete rewrite Yeah, I was just curious whether you were remembering or not yet as always I'd like to Keep up with what people are doing on routing because it tends to be the source of all of the failures that people say.

Speaker 1: 00:42:36

The other thing is the explanatory power, right? When something does fail, trying to explain why is kind of interesting. It means that with Rene'e Pay, I designed it not quite the way you'd expect. We basically run it naively. And then we go, well, there's a really good solution, but we can't use it because this peer is offline, or something like that. It's not the most efficient, but it does give you more explanatory power that you can say to them, hey, this, you know, because you've got like, you know, Alice has a direct channel to Bob and tries to pay Bob. But it's not online at the moment, right? Or it doesn't have capacity or something like that. It's really nice to mention why the obvious thing didn't work, because that's one of our main complaints. Why didn't this work? Like, well, you're not connected to the peer. So it's trying to route around and things like that. So it does in somewhat affect the implementation, because we do it more naively than you would expect, and then filter out the results so we can give feedback to the user.

Speaker 3: 00:43:31

Yeah, that's definitely a common complaint about all routers, I think. In other news, the node name on my public node has included a script alert tag for a long time. I finally got one. Someone was complaining that I was breaking their management software. So remind people to validate strings before they shove them into HTML. Also someone really should try the SQL version because I'm sure we'll get somebody eventually.

Speaker 0: 00:44:18

Does it work in mempool.space?

Speaker 3: 00:44:21

No, it doesn't work on any of the public ones that I've seen.

Speaker 4: 00:44:26

Too bad.

Speaker 0: 00:44:45

Oh, and Vincenzo mentioned getting feedback on LNPrototest on the mailing list. Well, maybe we can do that quickly.

Speaker 5: 00:44:53

Oh, yeah, I'm pretty happy to do that. We are planning to... We are in the process to rewrite LNPrototest to make this a little bit more nice to read, basically. And yeah, I was curious if some other implementation tried to implement Elenprotest runner and give up because it was too messy.

Speaker 0: 00:45:23

Yeah, we regularly said we would, but then every time we said we would, either Rusty, Lisa or someone else said, oh, but let me write some more documentation to help you know what you actually have to do. And then we've always just never came back to it. So we never did anything, but we would really like to do something to get compatibility with the end for today, but we've never actually done it. So feel free to rewrite whatever you want. I don't know if LDK or LAD has played with LNPrototest, but I think they haven't either.

Speaker 5: 00:45:59

Yeah, no, with LDK, I arrived to a prototype, but LDK is easy because you need to build your node, right? So at some point is pretty easy to support the LDK. And

Speaker 2: 00:46:17

yeah,

Speaker 5: 00:46:20

I am also in the process to write some documentation on how to write a runner for it. Basically, what I think some implementation is missing, some way to pass custom key to the node, to the lightning node. For instance, if a LM protest want specific channel key, private key, because we make some calculation on what we expect in the test. I, at least on the LDK side, I had some trouble to support the planar decay.

Speaker 0: 00:47:12

Sounds good.

Speaker 1: 00:47:16

Cool, I'm sorry, Vincenzo, I haven't reviewed your rework, but it's on my to-do list.

Speaker 5: 00:47:24

Yeah, now I am working on the way how to chaining part of the spec, right? If you want write the connection integration test, and then you want to use the same code to do the funding channel, I am working on this way to chaining previous test. And yeah. The previous test. And yeah.

Speaker 1: 00:48:03

The main purpose for LMPrototest is testing cases that never happen. So it's sending invalid packets, sending, you know, odd messages that aren't specced, stuff like that. That's been the main use for us. Not so much testing the normal happy cases, but testing things that never happen. Sending TLBs that you don't expect and things like that. That are harder to test in a black box testing way. So... I made it really hard to write this. Sorry.

Speaker 0: 00:48:37

It would also be really useful for all the, all the interactive TX testing where there's a lot of messages that the other guy could send out of under and it could create a whole heap of mess or being able to test that easily is really, really useful. I

Speaker 2: 00:48:52

think. Yeah.

Speaker 5: 00:48:55

Yeah. Also now we are implementing some, some big feature, right? Splicing all the stuff is really easy to say, okay, this is the normal workflow and what we get. And yeah, something like that.

Speaker 0: 00:49:25

All right. If we have nothing else, we can just call it a day and get back to work. Sounds

Speaker 1: 00:49:34

fantastic. Ciao.

Speaker 4: 00:49:37

Cheers.

Speaker 2: 00:49:44

Bye, guys.
