---
title: Lightning Specification Meeting
transcript_by: carlaKC via TBTBTC v1.0.0
tags: ['lightning']
date: 2023-10-23
---

Speaker 0: 00:00:04

All right. So I guess the first item is something that has already been hacked and is only once clarification. But I had one question on the PR. I was wondering, Rusty, for which feature you actually use that code because neither LND or Eclair handles. We just disconnect on anything mandatory that we haven't set. Where are you actually using that or are you planning on using it?

Speaker 1: 00:00:32

It's possible for pure backup. And it's possible for, if you're writing simple tools to connect to the network, they may not set the correct bits, but it's up to them to disconnect. So It's okay at the moment, I think, because all our requirements are symmetrical, but it's possible in future that we would have requirements that are not. But certainly if your peer sets a bit that you don't understand, you're supposed to disconnect. But if you set a bit and they don't understand it, that's their problem, not yours. So you should I mean, you know, it's kind of like they they can continue talking to you at their own risk, right? So you don't need to disconnect. And it's possible in future that I'm trying to think of a case there are some bits that are symmetrical. So you probably shouldn't enforce it. Like it's, you know, obviously if they say something you don't understand, you, you know, you hang up. But if they, if you say something they don't understand, it's kind of on them to do it. But there's no- We're talking

Speaker 2: 00:01:39

about 11.09, right? The one defining what off-word negotiating means?

Speaker 1: 00:01:43

Yeah, I think so. But basically, the point is that if you say you have to support a feature, you can just assume it, right? And you don't have to really check their features anymore. It's just like a simplification, really. You can just write code that assumes. If you say you must support this, then you can just write all your code assuming it does. And if they don't, they get to keep both pieces when it breaks. I think that's kind of the...

Speaker 2: 00:02:10

So are we saying that people should change their behavior? The behavior is okay? Because ours is that like, Upon connection, we'll disconnect. Is that still okay?

Speaker 1: 00:02:17

Or? Yeah, yeah, the behavior is okay. It's just that you don't have to check there's like at all. So if you set a compulsory bet, you don't need to check what they set, right? That's like, you can literally just write straight line code, right? You say, you know, say, say, you know, static remote key or something, you can set it as, you know, compulsory and then you can just completely ignore the behavior, right? Cause that's up to them to disconnect if they didn't understand it. So you don't need to check their behavior in that case. That's kind of the only corner. It's basically, you can, right? But you don't have to, is what it's saying.

Speaker 0: 00:02:51

We're just making it a bit more lenient on the sender.

Speaker 1: 00:02:58

Yeah, yeah. So you just, yeah. Making it clear whose responsibility it is. No, it's nice if you do disconnect, but who cares? Right, you can write code that's very, very simple that way.

Speaker 3: 00:03:10

I think this works as long as the sender doesn't have anything at risk or continuing to assume the receiver understands.

Speaker 1: 00:03:18

You never do. By definition, you can't, they could be buggy. I mean, you can't rely on anything. So you can just go, yeah, no, everyone's got to understand this and just assume they understand it. And if they don't, that's them, not you. So I think that was the only change. But also, yeah, just the words were not defined. That was where it started. We talked about the community that offered.

Speaker 2: 00:03:46

Can we land the PR then?

Speaker 0: 00:03:48

Yeah, I think so.

Speaker 1: 00:03:49

I think so.

Speaker 2: 00:03:50

All right, I'm going to hit the button. Cool. Done.

Speaker 0: 00:03:55

OK. The next one was about just actually specifying the 2016 default log time. I know that Rusty, you wanted it to be a one-liner, not one left it a four-liner or something like that to be able to have a reference to an extra section in the spec. Do you really mind or should we just hack it and not do

Speaker 1: 00:04:19

that? Just, that's fine. I just, I don't

Speaker 2: 00:04:23

know. Yeah, all right. Another merge?

Speaker 0: 00:04:26

Sounds good.

Speaker 2: 00:04:27

All right, I'll put it on here as well.

Speaker 0: 00:04:31

The mutual Close, simplified mutual close. Does someone else have an implementation or are we the only one?

Speaker 1: 00:04:39

You're the only one. I did want to add something cause I wanted to add the ability to say end sequence. I think that was the only thing we're missing.

Speaker 0: 00:04:47

Yeah, anti-fee sniping would be useful. I think it's a good opportunity to do all of those.

Speaker 2: 00:04:52

Yes. One comment here, I guess more of like a meta, I guess like textual one, something I think, so related to some stuff that we brought up, you know, during New York basically is that like, Can we remove the old one here? Because it looks like I've caught up 20 minutes ago. Do we think it's okay to remove the old one? Because I guess everyone's committing imminently to just doing this one. But then also, even with that, given that it has a feature bit flag here. Do we want to leave the old one around? Should we just move it to the end or something? Just thinking about like what the evolution looks like there.

Speaker 0: 00:05:22

We kind of have to remove the old one if we just want everything to be taproot at some point, right? Because this is the only-

Speaker 2: 00:05:29

At some point, yeah.

Speaker 0: 00:05:30

People that works for taproot, so.

Speaker 2: 00:05:33

Yeah, I guess I just mean like, in that, you know, it still takes time for this new one to be to sort of like, be take uptake me because we need to signal a feature bit still. And then we need to implement it, you know, to the side of the game as usual. Yeah,

Speaker 1: 00:05:49

I'm tempted to give it a bit of a gap like have both in there for a bit, even though it's awkward. And then

Speaker 2: 00:05:56

I'm having to move it to the end. I don't know, like, market section basically.

Speaker 4: 00:06:01

Yeah, I

Speaker 3: 00:06:02

think marking it deprecated is the right answer. Like that's because that's what form is. It's like this is around for like legacy internet, but we don't need it going forward. Do not implement this if you're playing to ships left soon.

Speaker 1: 00:06:15

Yeah. So the way I wrote it is the last commit basically removes it. But that was kind of so that we could discuss it. And I could, I'll toss the last commit and change it to something that marks it deprecated and put a few references. Whatever does the minimal damage so that what I'll do is I'll actually still create the commit that removes it to make sure it's pretty clean. But then

Speaker 2: 00:06:32

I'm gonna push

Speaker 1: 00:06:32

that command. Yeah, and then we can just

Speaker 2: 00:06:32

even stash that later to cherry pick. Cool. All right, so this is on my radar to actually take a proper look at again, given that we've got a bunch of feedback.

Speaker 0: 00:06:41

Yeah, because what do you do with LND? Because since in LND you started deploying type of channels, how do you close them right now?

Speaker 2: 00:06:49

So we close them with, basically everything is the same other than the co-op closed transaction has RBF signaled. And we do a thing where we do a fast close basically, where the responder just says, initiator, we're doing what you're doing basically. I think the idea was that we would then start to observe the new feature bit of this basically, and then if there's set switch to that thing, and then just start to ignore the old one basically. I think we have at least a pipeline basically to get in towards this one. It'll just be that new client, new client, they signal the feature, and they'll use this new one itself. Then in theory, if someone has a clock close present, I mean, we can code up the upgrade path, I don't know if you will, but then if it's unconfirmed, they can upgrade to this one and then do another bump, you know, in terms of just because it'll be RBF at that point. So, but that's like a great path. I don't know if we're going to implement that.

Speaker 1: 00:07:40

So, the other thing is if we allow them to set n sequence, we have to check that it's RBFable. So, that's the only twist on letting them specify what n sequence is going to be.

Speaker 2: 00:07:51

Oh, by RBF, what you mean like actual signals, RBF?

Speaker 1: 00:07:55

Yeah, so because I want to change it. We have a fixed, I think it's FFFFE as our n sequence. We want to be able, because there's that bit saying basically, you should try to blend in and here's how you should, really complicated, anyway, just, yeah. All it means for this is that you should, when you close, here's the end sequence I want, right? And we should make sure that is not all ones, right? Not FFFF.

Speaker 2: 00:08:20

Yep. And then so we actually use that exact same value as well in our thing today, the FFFD basically.

Speaker 1: 00:08:27

So yeah, that was the one that the spec currently says anyway, but we might as well give them the ability to set it because there seems to be a thing. So, yeah. I mean, if we're going to all this trouble, let's blend in. And then implementations can tweak it arbitrarily.

Speaker 2: 00:08:48

So good. Okay, cool. Arbitrarily. Okay, cool. I don't know. Maybe it's just

Speaker 0: 00:09:09

spec stuff, but from the spec point of view and the data per spec, there has to be some dependency on something to specify how you mutual close. I don't know if in the Daproot PR you have another definition for how to adapt the current mutual close. Because at some point we merge the Daproot PR, it has to have a defined way of doing the mutual close. Should we just say that to depend on that feature bit or something like that, or just depend on that feature?

Speaker 2: 00:09:37

I think, yep, I think that makes sense, because what we have deployed right now is the staging bit anyway, right? We can say the final bit assumes this thing. And I think that was the idea, but we at least wanted to be able to like, at least just do the RBF today, cause we knew we wanted that and then figure out the rest later. But I think that makes sense. Okay.

Speaker 0: 00:10:00

Right, so I guess next steps for that one is to have more implementation and add B326. Is that it? And just resolve the comments. I did not see a few comments about typos or closing SIG instead of closing complete in a few places. But Apart from that, it's looking good to me. We'll see when we do post-compact test.

Speaker 2: 00:10:23

And then also, I guess with this one, fee range doesn't matter much anymore, right? Because I'm just signing an offer, you're signing an offer, right? Or maybe it's useful for like bounds I'm not sure

Speaker 0: 00:10:35

it's not even included in the TLB stream of new messages okay

Speaker 2: 00:10:54

All right. What's next? The spec cleanup thing. So we have an issue for this one. I think we're trying to get this, basically do the initial required flip in .18, which is our next major release, which is like probably realistically like January or something like that. We always try to ship during the holidays and never happen. So it'll end up being early next year. But other than that, like we have this track change code wise is pretty minimal. It's just a matter of like seeing where stuff breaks around.

Speaker 0: 00:11:32

Yeah, it's on our master branch as well. And I think it will go on our node this week or next week, something like that.

Speaker 2: 00:11:37

Okay. Cool, And then I guess we'll merge this one once we are all actually start to signal it. Just then release that one and stamp them in the repo. Yep. Sounds good. Cool, which one offers?

Speaker 1: 00:12:13

Nope, nothing here. I've been slack, preparing for our release.

Speaker 2: 00:12:19

Our next release, which should be today, I think maybe tomorrow should have a basic version of offers just need a direct connection, but they'll lose me to wrap up for that.

Speaker 0: 00:12:31

And does anyone have the SCID or pubkey thing implemented?

Speaker 2: 00:12:36

We do not.

Speaker 0: 00:12:38

Okay, because we have a PR on Eclair that we want to get on our master brand soon, but it would be nice if we could test it against something else.

Speaker 2: 00:12:46

Is that the ability to use SCID or pubkey to make the thing smaller?

Speaker 0: 00:12:50

Yeah.

Speaker 2: 00:13:02

Cool. Next, splicing. I think there's a lot of like background movement on this, just in terms of like coalescing what everyone else's implementer thought of.

Speaker 0: 00:13:17

I guess one first question would be are you managing that PR Rusty or is Dusty managing it and should we I think last time I checked the PR already looked good and look seems to be what we had both implemented but just in case there are changes to make.

Speaker 1: 00:13:34

Yeah I'm leaving it to Dusty. We're leaving experimental this time. I've got, I saw CI get a bad signature recently, so I'm like, okay, there's still some fun in corner cases with splicing, where we definitely can break things. So it's still gonna be experimental this coming release. So we're supposed to be code freezing, well, we're supposed to do a November release. So the clock's kind of ticking now. So The code's not, you know, it's not quite where I'd want it to be for if we make it official. But yeah, I've been letting Dusty run with the PR. So I have not looked at it recently.

Speaker 5: 00:14:11

Yeah, and I've been just busy trying to get all the restart related nuances going. And once I get that done, then I plan on getting to the spec right after that. Yeah.

Speaker 0: 00:14:26

Sorry. Yeah, that's probably why you get a few invalid committing errors. When you start implementing all the restart stuff, There are a lot of cases that you need to properly implement. Once you figure out the state machine, everything makes sense, but that's where we found a few bugs where people just disconnect at the wrong time, or even restart from the wrong backup and it's not properly handled or something like that. And it's interesting. It's interesting to implement.

Speaker 2: 00:14:54

Cool. And then this is defined like in the TLVs and the reestablishments, right? Which is sort of how you're supposed to like in theory synchronize.

Speaker 0: 00:15:01

Yeah. You just add one TXID in the TLV. When you were in the middle of the signing section, when you disconnected, you just add the TX ID of the funding transaction, the splicing transaction you are creating so that the other side knows that they have to retransmit commit SIG and potentially TX signature if they were the first signer.

Speaker 6: 00:15:22

Cool.

Speaker 0: 00:15:25

And by the way, we'd really love it if Sea Lightning had the support for the dual funded part of that so we could lend dual funding. Is that

Speaker 2: 00:15:34

related to

Speaker 0: 00:15:37

the restart? It's only the restart part of the channel reestablish. Was that what you were working on, Steve, for dual funding as well?

Speaker 1: 00:15:46

I haven't

Speaker 0: 00:15:47

done the

Speaker 5: 00:15:47

dual funding part of reestablish, just the splicing stuff. Is there something for dual funding you're hoping to get done?

Speaker 0: 00:15:54

Yeah. This is really, oh, Lisa is here. This is the missing bit for dual funding cross-compat, And it shares code with splicing. So I guess this is code that is put potentially in both your branches.

Speaker 2: 00:16:10

Is this like a case of like restarting a dual funded splice or like a restarted splice with dual funded channel or?

Speaker 0: 00:16:16

Restarting anything that uses interactive TX, whether it is doing funding or placing transaction, restarting something where you disconnected in the middle of the signature process, like one side sent commit SIG or maybe commit SIG and TX SIGs, but didn't receive everything. And when you reconnect, you want to make sure that you finish the signing session. I think Lisa has mic issues. We couldn't hear you. Yeah, we can't hear you, Lisa.

Speaker 1: 00:16:50

She did promise yesterday she was back in Texas and she was going to be working out on some dual funding stuff. So Lisa is right now promising that yes, it is almost finished and it is working perfectly and it will happen.

Speaker 2: 00:17:02

Cool.

Speaker 1: 00:17:03

Wait, I think I heard something. Yeah, there you

Speaker 2: 00:17:06

are. You're there.

Speaker 4: 00:17:08

Hello.

Speaker 1: 00:17:17

You're alive.

Speaker 4: 00:17:19

All right. Sorry.

Speaker 2: 00:17:20

Yes.

Speaker 1: 00:17:21

I don't know. Can you hear us?

Speaker 4: 00:17:22

Yes, there's one. I think there's like one left to do with the dual funding stuff on Reconnect and I'm working on it this week. So, but we need, I don't know where the current release process is, but there is a slim chance we get it in the next release. I'm not gonna make promises though.

Speaker 1: 00:17:41

Yeah, you've got six days. Actually, you've got slightly more than that because it's experimental. I mean, I'm not released captain, so you'll have to like ask the captain, but nominally, you know, if you have a PR up in the next week, you probably should be good.

Speaker 7: 00:17:56

I heard RC1 by Monday, hopefully.

Speaker 1: 00:18:00

Yeah, that may be optimistic, but it's good to have goals.

Speaker 0: 00:18:06

And if you want cross-company tests, just ping me when you have a branch and I can test that branch against Eclair and let you know if everything seems to be working good.

Speaker 2: 00:18:21

Cool. Okay. Taproot stuff, if we're moving from dual funding. So last thing on this one, OK, it looks like there's two, or maybe there's a few things I didn't catch up on. Last thing I remember at least was like, you know, Tbat's talking about like the extra nonces for the purpose of splicing basically. And like, you know, if you are splicing a tappery channel, you need some additional changes there. Defining constant path.

Speaker 1: 00:18:54

Okay. Yeah,

Speaker 0: 00:18:55

and that one is actually a question where we'd need feedback from Dusty on the splicing path because the first proposal I have doesn't need any change to your current TLVs, to the current TLVs that you're using. We just use the implicit ordering of the Splice transactions and order the nonces with that implicit ordering. So TLV just handles that without changing anything. But if we do not want to rely on an implicit ordering of a splice RBF candidates, then we'd need to change to do a breaking change on the TLVs. So that's something I think we should decide soon. But in my opinion we should keep relying on the implicit ordering that a splice transaction has to be created after another one just because there's this splice protocol state machine. So you just order the non-sys in that exact same order.

Speaker 5: 00:19:45

Yeah, and this is to me. I think the current spec does require them to be ordered in fee rate, which is essentially the same as the order in the creation order of the IBFs. So I think being structured is a good idea, the order.

Speaker 2: 00:20:00

Cool. And then just curious, what would the explicit ordering look like? That would basically be like, you know, number or nonce, basically, or fully enumerate them on the wire kind of thing?

Speaker 0: 00:20:09

I think if you want it to be explicit, you would have to do like a map funding Txid and nonces. Or splice Txid if you prefer, and nonces.

Speaker 2: 00:20:21

I'm just curious what that looks like.

Speaker 0: 00:20:23

But I think just relying on keeping the order in which you created the transactions is the easiest.

Speaker 5: 00:20:30

Yeah, I like that too.

Speaker 0: 00:20:33

Yeah, perfect. Then in that case you don't need to change anything in your current TLV format. It would just work because the length is already encoded.

Speaker 2: 00:20:43

Love it, let's go. Cool, okay. And then I think the other thing which I think we got some more comments on was basically the thing around mini script. Just to double check that the scripts are mini script itself. I think I asked a question on descriptors. Looking at that. And then it looks like there are a few areas maybe where like one byte was saved. It looks like some of them I think are instances where we like opted not to use the CSV trick. I probably need to like look at it a bit more. I think one byte not considered compatible.

Speaker 0: 00:21:22

Yeah, the rationale about making it miniscript compatible is not really to save one byte, but just to be able to import those policies directly into BitcoinD instead of having to explicitly spend the output. This way we avoid the third stage transaction and instead of broadcasting it, we just tell BitcoinD this is the descriptor, please include it in whatever next coin selection you do and we save one on-chain transaction. And anyone who would like...

Speaker 2: 00:21:50

Yeah, I guess like, I'm not too familiar with this, but I guess like how does Bitcoin.d do like the, you know, satisfaction basically, right? Like, because you're giving it a bunch of other stuff, right? And it just knows, I guess, that's the magic of MoneyScript or just curious about that at least.

Speaker 0: 00:22:03

I think they compile it internally. At least they run the compiler code internally. But I'm

Speaker 2: 00:22:09

not sure. I guess I meant more like it obtaining the input. Maybe that's a manual step anyway. Like it can at least observe it, and then it asks you for the pre-image and you give it to it or something like that.

Speaker 0: 00:22:21

Yeah, I don't know if anyone knows this part of it.

Speaker 6: 00:22:23

Oh, you mean for spending it when you do the import descriptor with like, because there are a bunch of parameters there, right?

Speaker 2: 00:22:30

Yeah, yeah, that's what I mean. Just curious like what the API looks like.

Speaker 6: 00:22:34

Yeah, good question. Has anybody actually used Bitcoin D RPC API to spend?

Speaker 2: 00:22:41

I think now they recently added Tapscript support as well, which is I think newer on the Bitcoin D sub, maybe it was already specified, but that's another thing that I think happened recently.

Speaker 6: 00:22:54

Okay, I'm actually really curious too. That is a fascinating question.

Speaker 2: 00:23:01

Cool, And I guess it was like he ignored the revoke script because like there's sort of like a, you know, thing there to make the anchor still sweepable. But probably one thing I think would be useful is just to look at exactly what the diff is because it says like one byte here save. I'm not sure exactly where that one byte is. I don't know if it's like an op drop. It looks like it most likely maybe the op drop

Speaker 1: 00:23:20

gets

Speaker 2: 00:23:21

moved or eliminated.

Speaker 6: 00:23:28

Yeah, I think it is because when you don't up drop it, it actually still ends up being true. And then the true is equal to the one and then you can do that.

Speaker 2: 00:23:37

Yeah, exactly. And the funny thing is, I think someone, you know, pointed this out very early on, but we were like, oh, that's kind of hard to understand, right?

Speaker 6: 00:23:44

Yeah, we were talking about that. And so that is why we're initially leaning towards keeping that in just for clarity. But because many scripts is to optimize, I guess if we value the importability, we're going to abandon the clarity. But Yeah, it's like that thing with not using nonce for unilateral closes. I feel like there are both drawbacks and benefits to both positions.

Speaker 2: 00:24:11

Yeah, yeah. I mean, I guess like, you know, I think it Feels like the miniscript art is, I guess, is strong enough, particularly people are aligning their tooling with that.

Speaker 6: 00:24:19

And well, it depends. I think it depends on whether people are actually going to be able to easily provide the necessary arguments to spend from Bitcoin. And if that is, I guess other wallets will also be using, I guess other wallets also use many scripts to import the scripters. So maybe not necessarily. However, I do think that it requires the spender to know a certain amount of state that might be rather inordinate for the usual Bitcoin transaction output. Because all of a sudden your on-chain wallet needs to be aware of how your Lightning wallet worked and what the pre-image was, et cetera.

Speaker 2: 00:24:56

So. Yeah, I've been following this, but like here's a PR from, I guess it was merged two weeks ago that adds TAPscript to Miniscript. And because as far as I can tell, like, well, I guess the thing is, I think in most cases, like our branches are pretty simple, but I think this one would let you do the top level of TAP root one, which maybe does something. So that's, But I guess this is the same OP, so I'm assuming they know what they've done that properly.

Speaker 0: 00:25:20

Yeah, and to be honest, we don't actually need Miniscript compatibility on all scripts. The only ones where we really need it are the two local and two remote, just to avoid the third stage transaction. So those ones are easy to make compatible and maybe they are already, no, one of them is not.

Speaker 2: 00:25:38

Yeah, I think one of them, one bite.

Speaker 6: 00:25:40

Yeah, wait, but Lalo, what do you mean with just key spend, with the top level spend? I thought that is now a nums point.

Speaker 2: 00:25:50

That is, well basically I think he's saying that he was ignoring one of the scripts because one of the scripts just pushes data onto the stack so someone can get it, you know, so someone can like use that data to sweep an anchor if they need to. So I think he was saying that he ignored that because according to Miniscript, that's useless, but for us, we have an application level use for it.

Speaker 6: 00:26:08

Okay, I see what

Speaker 2: 00:26:09

I mean. Yeah, because otherwise, Miniscript would optimize that out because it realizes it's not used for the script at all. But cool, yeah. So it looks like everything is just basically, in a nutshell, getting rid of the op drop. I don't think any of the witnesses changed as a result. Maybe there's a pubkey ordering thing that does. But OK, I'll look at actual side-by-side diff. Maybe I'll post that too, so it's a little bit easier to see exactly what that looks like. But yeah, otherwise, it makes sense.

Speaker 6: 00:26:37

The witnesses should not change because the value is coming from the script not from the input, not from the redeem script.

Speaker 2: 00:26:44

Yeah. But if whatever reason it swapped a pubkey ordering, I don't know why it would, maybe it would, but yeah, I think you're right, the witnesses shouldn't change. Yeah, and so I guess a good thing I haven't done the weight estimation test vectors yet as well, because now, you know, minus one and everything, but okay, cool.

Speaker 6: 00:27:00

Well, after 118, which is now this pretty quick release that we're doing due to a deadlock, we should be able to merge Taproot stuff for ending in 119, I'm looking forward

Speaker 2: 00:27:12

to. Exciting.

Speaker 6: 00:27:16

Oh, has there been anything new regarding gossip? Is L on the call yet? Wait, no, that's L.

Speaker 2: 00:27:24

So L is not here, but she asked her to pick up gossip stuff again. And, you know, so we're just like, first, one thing that we're doing, I think for .18, I think I mentioned last week, or the other thing, we're actually implementing the timestamp for everything now, because we realized that without that, we have a hole in our graph, because sometimes we don't get a zombie, we don't hear about a zombie transaction, or our channel doesn't get much records, so we're doing that. But I probably need to check my notes on the gossip stuff. I think last we were looking at like some of the stuff to add compatibility basically, and sort of like what that upgrade path would look like. For example, like when people upgrade, are they gonna start to send all of their old channels with the new style thing? Will they only do it going in the future? I think we were just discussing what that pipeline looked like. And then also, based off of that, do we still need the backwards compat announcement stuff there, basically? Or I guess also, would we be announcing backwards compat stuff with Schnorr signatures as well? I think there's some things that we're not like, you know, chatting about with her or it came up, but.

Speaker 6: 00:28:26

What about when you announce backwards compatibility, backwards compatible, or do you mean compatible announcements or announcements regarding compatibility?

Speaker 2: 00:28:35

So basically announce a SegWit v0 channel using the new scheme. Exactly like, you know.

Speaker 6: 00:28:42

Oh, I see what you mean. Yeah.

Speaker 1: 00:28:46

Yeah, we did come up with a scheme for that. We thought about trying to retro in using the old signatures and stuff. It's just too fucking ugly. So basically, it is it's nicer if we've got this. I mean, we're gonna have to this transition stage where you're gonna have, you know, old style gossip and new style gossip anyway. It's not too bad to have to like shoehorn a couple of these, right? You shoehorn the old so so you can announce the old style SegWit v zeros on the new gossip thing. So we can actually transition without ever having to close their channels. It's not too bad. And then, you know, ideally that gives us a nice transition, right?

Speaker 2: 00:29:23

And we can eventually stop

Speaker 1: 00:29:24

with old gossip.

Speaker 6: 00:29:26

How can you announce old gossip using, I mean, old channels using the new one, if you now have 50% of pubkeys that are not going to be representable?

Speaker 1: 00:29:37

Oh, you have, no, you have a tier.

Speaker 2: 00:29:40

I'll use my pubkeys too.

Speaker 1: 00:29:42

Yeah.

Speaker 6: 00:29:46

But like if you're using.

Speaker 1: 00:29:50

You can still invert, it still works.

Speaker 2: 00:29:52

Okay, all right, so I think, So I'm looking at some of these notes here that I had from last time I chatted. So I think one question we were asking is that, to my knowledge, I think it's not that you'll reannounce the old channels with a new scheme, it's that you can send a new channel update. You can send channel update 2, right? Is that your understanding, Ryski? Or are you saying that you would reannounce the entire thing? Or just send channel update 2?

Speaker 1: 00:30:13

I think you probably want the whole thing. I mean, it's the... I'll have to go back and check my notes too. I mean, I do want to turn off the old gossip at some point, and not wait for everyone to close. Everyone to have reopened all their channels to do it. But I spoken to someone who hasn't actually implemented it yet. I reserve the right to change my mind if I run screen when I actually meant this right but We're currently it's one thing didn't get in this release but it was on is basically to rewrite our whole gossip handling because you know It kind of evolves over time and now I'm like no no before I put this new stuff on top, I want to

Speaker 2: 00:30:49

basically rip.

Speaker 7: 00:30:50

Yeah, I

Speaker 2: 00:30:50

was looking at doing something like that to ourselves.

Speaker 1: 00:30:53

Yeah, exactly. It's

Speaker 5: 00:30:56

we did fix that

Speaker 6: 00:30:57

nasty RGS bug this last Friday. So now we no longer need Gosp. Everybody can just bring that server.

Speaker 2: 00:31:06

Oh yeah, we can just use Aric's server. We can run our own too. Okay, so other thing I wrote down was like, okay, you know, no announcement to everyone can just start to, you know, advertise that itself. I think the only thing that we were discussing was sort of like basically just vector bookkeeping. Not like significant, so basically send both versions. I think something around comparing timestamps versus block height, right? Because for the old channel, it'll have a update one with timestamp, and then on update two with a block height. I remember exactly what we were trying to drill into there, but I drew that down that for that channel, you have both versions. I don't know if it really matters much.

Speaker 6: 00:31:46

I thought announcement only had block height and then updates had both timestamps. And yeah, I thought it was based on the semantics where announcements had the block height. Correct. Yeah.

Speaker 2: 00:32:00

Announcement has an SID, but channel update has a timestamp. Channel update one has a timestamp, but channel update two, we're looking to just move to block hide every row for the most part.

Speaker 1: 00:32:09

Block hide. Yeah. Which is much nicer.

Speaker 6: 00:32:12

Yeah, I agree.

Speaker 1: 00:32:13

Yeah, the question is what happens when people do a query, which one do you return? And I think you blast both of them. Because you still want to propagate. So the thing is, even if people understand the new one, you still want to propagate the old one, right? Because most people are gonna have to be bilingual for a long time. That makes queries a bit weird. I think maybe we have to think about that. Like so if someone says, Hey, I want everything from this block height onwards. Do you just go well, I'm gonna give you the I'm giving you the latest v2 one. So I'm gonna give you the v1 one as well, because why not? Someone has to think through all that.

Speaker 2: 00:32:51

Yeah, and I guess they can just ignore it if they don't understand it. So you reset the message typewriter or whatever.

Speaker 1: 00:32:59

Yeah, exactly. I'm thinking we,

Speaker 6: 00:33:02

huh. Do you envision new queries being able to query by both block range and the Frankstum range?

Speaker 1: 00:33:10

I don't know. So I'm hoping that we go to mini sketch and we basically just, you know, just sync the new stuff, but that won't help for the old ones.

Speaker 2: 00:33:20

Yes.

Speaker 1: 00:33:23

But in my head, I've got it so that you basically just deal with the new ones all the time. And if you've if I'm ever going to send you a new one, and there's an old one tagging around, I'll send you the old one as well. And you can just ignore it or whatever you want.

Speaker 2: 00:33:33

Also, in theory, you can convert between a timestamp and a block height, given some, you know, arithmetic, right? So it depends. If you want to put it all in the same bucket, you can do it, right? So... Yeah. Well, if you just assume about, you know, like 10 minutes per block.

Speaker 1: 00:33:48

Use the median time.

Speaker 2: 00:33:49

Or just use the timestamp of the block height itself.

Speaker 1: 00:33:53

Offset by an hour and use the median time.

Speaker 7: 00:33:55

I went down this rabbit hole and I think it's uglier in practice than in theory. It sounds like it's feasible, but until you implemented it, I don't know, I'd hold off judgment there.

Speaker 1: 00:34:08

Yeah, the other thing is that you end up with a thing that can't happen, which is that you can have two timestamps that land you in the same block height. And then you're like, well, are these the same update, or are they different?

Speaker 7: 00:34:19

Yeah. Right. I mean, what happens if you get a one block reorg, then you got to look at all the most recent stuff.

Speaker 6: 00:34:31

Yeah, a timestamp could also feasibly refer to multiple blocks, considering that with the median block height and the up to 2R drift, it could be really anything. So you have to, like, any timestamp could probably map to a range of maybe like 12, 15 blocks?

Speaker 1: 00:34:51

No, the median time has to move forward so you can use median time and have some offset and you'll get a specific block, but it doesn't really help you that much because you could still end up with multiple. Yeah, I mean, that conversion is theoretically possible, but it's ugly and seems kind of unnecessary. It's possible that we'll end up with some, Anyway, yeah, we really have to step through and see what this is going to look like, right? Especially with all queries. Like, do we want a new set of queries? And what is it going to look like? But I would definitely like to do mini-sketch across this. One of the things about block height is it does make mini-sketch a lot easier. But yeah, for a long time, we're going to have to deal with the old stuff.

Speaker 7: 00:35:38

Yeah, that was basically the last roadblock to mini sketch, so for set reconciliation.

Speaker 2: 00:35:48

OK, cool. All right, I'll funnel some of that back over to Elle. I think it's just like some of the points that we had like when I was looking at it to take a look at. I think she has some code now she has like the messages. I think the start of some of the new stuff, but I don't think she's like looked at like what the backwards compat stuff looks like as clearly as far as like, you know, advertising deal with the new, but at least like we can do the new and then make sure the old, you know, isn't super weird. Cool, yeah. It looks like we have some initial code towards that. I think by next time maybe we'll look at some of the backwards compatibility stuff a bit more. But yeah, we just have legacy stuff where it's like, we can store the node announcement too by having some random prefix in the database or we can just make it all better, you know, before we start to do all these hacks on top of it, but we'll probably just work through some of that, so. And we're just generally trying to overhaul a lot of storage stuff in LND right now too, so. Cool, okay, all right, that was two birds, That was typewriter and typewriter gossip. Next, we had attributable errors. I don't think Yoast is here, though, but we were looking at this and also the inbound fee stuff on the L&D side. I think once we get through further on that, I think a Claire actually had an implementation or a comment rather, but I think you just have to look at the PR in a bit. But we could in theory start to do interop there? Because your are just sort of like sitting there, so.

Speaker 0: 00:37:22

Yeah, I think we could because we have a branch, we haven't merged it to our master branch yet, but I think it's ready and should be implementing the latest spec, unless there are feedback, there's some feedback on the spec. But I think, yeah, I think everything is just waiting for cross-combat on our side.

Speaker 2: 00:37:37

Pretty cool. All right. I think Yoast about that.

Speaker 0: 00:37:43

Well, there was some comments from Thomas on the safety arm that haven't been looked at by Yost, if you can have a look at them.

Speaker 2: 00:37:55

All right, I'll just link that to him directly as well. Oh yeah, feature goods. Oh, yeah, feature goods. Check, you know, my quarterly homework to t-BAS. Still there. Maybe I'll try to get someone else to look at it. It's there. It's going to happen.

Speaker 0: 00:38:24

I think it's more annoying to review than it was to write, so you're going to have a hard time.

Speaker 2: 00:38:29

All right. I'll make sure to get some nice coffee before I sit down with that. Going down, inbound P stuff, I think similar position. We're doing some review testing and stuff like that. And also, we were focusing some more on blinded path stuff, basically, to get some of that into 18. I think Carla's pathfinding has been merged in. We have a follow-up for that. And then we're also working on forwarding on some other things around recognizing when an error comes from within the tunnel versus outside, things like that. So moving forward on that. I think that's where all some of our attention was instead of some of the other inbound stuff and things like that. But yeah, so the goal is at least to get that base version into 18, which is like 10 weeks from early next year. And then we can move forward with everything else from there to complete the stack. And I don't know if you have any direct updates on that. I think we've all been interopting for some time now as well. It's just a matter of getting through the remaining PRs. I'm a randallist.

Speaker 4: 00:39:37

On wrap learning stuff?

Speaker 2: 00:39:39

Yeah, wrap learning stuff. I was trying to give an update for you.

Speaker 8: 00:39:42

Yeah, yeah, yeah. So we're into upping paying CLN and LDK, and then I've just got to follow up to do the like handling the error in the right way and then I'm still busy reworking the forwarding one which is just infinitely growing in size so yeah just breaking that up into two smaller PRs And that also works and is interopting, but obviously needs review and everything.

Speaker 2: 00:40:04

Cool. Okay. Yeah. So, you know, the HTLC's flow, you just got to finish up the actual code of it. Cool. Any other grab bag stuff people want to discuss?

Speaker 0: 00:40:21

Yeah, there's one thing I wanted people's opinion on. It's the email about zero reserve that I sent to the mailing list. The link is here. Just wanted to get feedback from people to see if I missed something because we've been doing zero reserve for a while on Phoenix but we were only doing zero reserve for the Phoenix side where we were actually taking a risk but it's a measured risk because the user has paid us fees to get into the system anyway So even if they publish a revoke commit, it's okay. We can just, we know they're not going to be able to steal money. We're going to be able to penalize that. And I think that it's easy to argue that the other side works as well. And that it's, It's mostly a good thing to allow the LSP to be zero reserve as well. But I'd like people to just check my, if they think the incentives are okay, and just tell me if you think there's a strong knack or if it's okay.

Speaker 2: 00:41:14

Yeah, I guess My initial take is like, I view it's kind of like the zero conf, you know, channel type in the first place, basically, that like, you can opt into it, and it's sort of your risk type of thing, or like, are you proposing something different in terms of like making it a blanket thing or, or like, I guess, I guess, like, or just permitting someone sending it to setting to zero in the actual initial funding flow?

Speaker 0: 00:41:36

Yeah, but the interesting thing is that even if it's set to zero, yeah, the goal here is that whenever you do zero reserve, you do it on both sides. But even if it's set to zero, the channel initiator still has to be able to pay the fee for the commit. So it's not an additional reserve on top, but it's still something. And that plus the reputation and the fact that they should be earning fees from you, I think is OK. It's OK. But the fact you And also the fact that just even publishing, being able to publish a revoked commit and having an incentive to do that instead of publishing the latest date doesn't bring you much because in practice, you're never going to win. So yeah, you could do that, but it's exactly the same as L2, where you can always publish for latest date, and you are wasting on chain fees by doing that, but you're not going to win anything because people are watching the chain and are not going to let your revoked transactions go through.

Speaker 4: 00:42:31

But I think that's the point of like a mobile node right or like the mobile node is probably not watching the chain and you will win pretty large percentage of the time. It's only open the mobile node once a month.

Speaker 0: 00:42:46

But if they only plan to open it once a month, they should put the self-delay to two months.

Speaker 4: 00:42:53

Okay. Does Phoenix let you configure that?

Speaker 0: 00:42:55

No, but we tell people they should connect regularly. But we put notifications. The app runs in the background. If it's not able to connect to its Electrum server and check the chain, it's going to warn the user that they should come online.

Speaker 4: 00:43:11

Yeah, but people just ignore notifications. Like, That's not a thing.

Speaker 1: 00:43:17

The argument is stronger for L2 because watchtowers are so trivial, right? So, it's not... I think the argument is possible to make, but I think it is definitely stronger for L2 where anyone could be a watchtower. You could run, you know, one of us could run a watchtower for the whole network, quite trivially, with L2.

Speaker 2: 00:43:44

So two questions. You're saying it's not actually zero because the initiator still needs, so it's zero for those final, but the initiator still needs the fees to pay for everything, basically, right?

Speaker 0: 00:43:54

Yeah.

Speaker 2: 00:43:56

Gotcha, and I guess you, I mean, one of the things that we're gonna officially implement, the whole fee buffer thing, We have a PR for that now. This is like to me, we're into a while back, you basically need a buffer. I think we're just matching the behavior of declaring to lightning, which you'll learn I think now with as far as the amount. That reminded me of just match cases with reserves and fees. But I guess I can check out the thing more. I think mine is just like, yeah, I guess if both people said it, they both opted into it, right? So I don't know. And, and, you know, people do zero conf in a similar way already.

Speaker 0: 00:44:36

It's basically that

Speaker 1: 00:44:36

zero conf is transient trust, right? So this is a slightly different, you know, zero conf is like, you're, you're kind of like out on the ledge for a little bit, but you know, confirms happen, and then then you're happy again. This is a longer term, you know, trust issues. It's not quite, you know, quite the same. But I tend to be like, I somewhat agree, right? There's There's definitely a UX win to having zero reserve, right? You don't have-

Speaker 2: 00:45:04

Yeah, and a lot of mobile nodes, because I know, for example, I know Breeze with their LNE version does this. A lot of people have been doing this for some time already, so. It's an old little corner.

Speaker 4: 00:45:16

Yeah, we always allow our counterparty to give us zero reserve, but we never set it. So I think that's like what Phoenix does. We always like if our counterparty wants to do something, we let it.

Speaker 2: 00:45:29

That makes sense.

Speaker 0: 00:45:30

It's certainly a thing. The main issue is that especially when we start moving to channel reserve is 1% of the total capacity, which means that as an LSP, you have to put in reserve 1% of all of your users' funds. So that just doesn't scale. As the LSP, You just cannot really scale because if you have to keep a new liquidity that is 1% of all your user base, all of their money, not yours, it's just a lot of wasted capital. I

Speaker 4: 00:45:58

mean, you shouldn't set it to 1%, right?

Speaker 0: 00:46:01

Yeah, but that's what happens by default. So then we started thinking, oh, but maybe then we should override that to a hard code to another value but then we said oh but does it really make sense to have it at all and that's where we got that's why we got here

Speaker 1: 00:46:17

yeah I think the original splicing, the original tool funding just, I think, nailed it to 1%. It's like, that's what everyone's using. But I somewhat agree, like 1 and 0 are like, are the compelling values, right?

Speaker 0: 00:46:34

Yeah, because it's annoying. We have users that have 10 BTC channels. So that means we have to have 0.1 BTC just in reserve for them. It's really a lot, it's really wasted capital. And those people are usually not using lighting much. So. I'm not using lighting much, so.

Speaker 2: 00:47:01

I guess I need to check if we allow it or not. I think maybe we disallowed explicitly, at least if we were looking to move something like LDK's approach where we let people just set it, but then, you know, or we let people set it for us, but then accepting it is different, or setting ourselves different, rather. Because we need a flag for that. And a good point about the whole, I guess, over time many channel thing, around that 1% of the queue of 1% as well. I hadn't thought about that before. I guess I'll check out the email. Yeah. I guess the behavioral change here would just be like everyone lets people set it or without the feature bit or I guess what do you think this will look like deployment wise to us?

Speaker 0: 00:47:59

Yeah it's that we use a feature bit and that feature bit means that both sides get zero reserve.

Speaker 2: 00:48:05

Sure. I've got to hop off here in a bit, but I guess while we're here, anyone have questions around this whole RBF thing? We're assuming we know, we know the skinny.

Speaker 1: 00:48:52

No one wants to touch that. No one wants to touch that.

Speaker 8: 00:48:53

No one wants to touch that. I have a miscellaneous thing which is unrelated. It's just so if anyone would like to, on Friday, Chaincode's running a research day, which the goal is to nerd snipe some researchers into working on Bitcoin and lightning. So we've sent a few people emails, but just if you have anything on your wishlist that you'd like to try and get some academics interested in. If you want to send me like a one page write up of what that is, we're going to have them on display so that folks can sort of get interested and reach out to people working in the development space. So just a little show there if you want to try and nerd snipe some academics. We're doing our best.

Speaker 2: 00:49:34

I just posted the link in chat here as well. It's brd23.com, nice domain. Yeah, I need to figure out my travel plans and stuff. Okay, cool. Thanks for the plug there. And that's this weekend, right?

Speaker 8: 00:50:00

That's Friday this week, yeah.

Speaker 2: 00:50:02

Friday. This Friday. Okay,

Speaker 0: 00:50:03

cool. Cool.

Speaker 4: 00:50:04

So if you want to submit stuff, it has to happen like today or tomorrow or whenever?

Speaker 8: 00:50:10

Yeah, I mean ideally Thursday. It's just sort of a one page that we print, but yeah.

Speaker 2: 00:50:19

Cool. Okay, cool. With that, I posted my notes on the thing and thanks everybody. Cool. See ya.
