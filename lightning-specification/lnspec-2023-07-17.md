---
title: Lightning Specification Meeting
transcript_by: carlaKC via TBTBTC v1.0.0
tags: ['lightning']
date: 2023-07-17
---

Speaker 0: 00:00:05

All right. Does anyone want to volunteer to take us through the list? Nope. Okay. Um, I will read the issue that Bastien very kindly left for us then. The first item on the list is bolt 12 chaining keys clarification. Is there anything we need to talk about here?

Speaker 1: 00:00:53

Oh, bolt eight. Okay, cool. Just checking. You said

Speaker 0: 00:00:56

12. Oh, sorry. Bolt eight. Yeah, The first one on the list.

Speaker 1: 00:01:02

Yeah. Yes, it's almost under the spelling rule, but I think it's been acted by everyone. So unless people have objections to the specific wording. To be clear, it's not a change, it's just a clarification. Based on Ellen Socket's misimplementation of rotation.

Speaker 0: 00:01:26

Cool. Well, I guess someone can hit merge. It's got enough axe.

Speaker 1: 00:01:31

I'll do that.

Speaker 0: 00:01:32

Hit the button. Next one, we'll see you, Rusty. Spec cleanup. I took a first look at this today. And Bastions had a look, but I guess it'll need a few more people to volunteer to take a look at the cleanup that we discussed in New York.

Speaker 1: 00:01:50

Yep.

Speaker 0: 00:01:55

There was some discussion on this about what was it decoupling Is Matt Morehouse here? I think he commented about this. Anyway, I think Bastian can comment on that next time. Anyone feel free to chime in at any point. Is there anything here you want to talk about, Rusty?

Speaker 1: 00:02:27

No I think, I'm finally reading through the comments. Sorry. Yeah. There's a question on

Speaker 0: 00:02:41

here it is option static remote key being dependent on anchor outputs. Yeah.

Speaker 1: 00:02:47

Or the other way around, anchor outputs dependent on options static remote key. So, Bastion doesn't want to assume it, but I think, I'm not quite sure why, but he does comment that,

Speaker 2: 00:03:11

he says the

Speaker 1: 00:03:11

whole section we should remove.

Speaker 2: 00:03:13

He's saying he wants to use it as a flag to say I don't support non-anchor channels. Basically, if you unset that, it is an indication that you only support anchor channels, is what he's saying.

Speaker 1: 00:03:27

Right. Right, okay. Right, okay. But you can set anchors to compulsory, I guess. Although then you've got the problem that all clients can't connect to at all if they've got an existing channel with you.

Speaker 2: 00:03:53

Well, then we have the issue too where you have set, you can't do taproot because you require anchors, But I guess taproot also uses anchors. I don't know if there's like some new anchor v2 something, something, then you couldn't set it to compulsory.

Speaker 1: 00:04:11

That's true. I mean, if you put it in a message, then then if someone has an existing channel, and you want to support that, but not support new opens, then there's no great way of doing that other than rejecting the channel open, but they can't tell just by looking at you, whether you would, whether you're whether you are making things compulsory, because, yeah, so yes, okay. We had this problem before. I'm not sure that static remote key is really the best way of doing it, but I think removing the explicit dependency is correct. So I think I should remove that requirement, and also the whole initial sync section, and there's some typo fixes. So this does seem like it needs a little bit more revision, but I think it's clear that people are broadly supportive. So it's just a question of turning around a few times. I think basically you could ship this today. You could assume everything today and no one will care. You won't get any bug reports because in practice, everyone says these bits and I think that we have consensus on that. So that's good. Cool. Okay. I will commit to going around again and tweaking this a little bit and having the debate with Bastien.

Speaker 0: 00:05:32

Cool. Sounds good. Next in the list, we've got the two blinded pods PRs. Matt's won 1066 and I think Val's won 1069. At the summit, we said we'd update one of these to have the absolute block height, and then the other one, I don't know if we need any changes there, the updates here?

Speaker 2: 00:05:56

Yeah, no, there's no updates as soon as we get this next release out. And then probably the one after that. Then I'll have time to work on the spec.

Speaker 3: 00:06:08

Yeah, I just need to clarify something, something about the delta calculation from the invoice expiry. But we'll get to that.

Speaker 2: 00:06:17

If someone's annoyed, they can happily take over my PR. I know I've been holding that up for a while and we'll do it eventually if no one does it. But if someone else does it in the next month, you will probably beat me to it and you're welcome to take it over.

Speaker 0: 00:06:32

Okay, I might grab this one from you because I'm busy working on this now, indeed, but don't hold me to that. Yeah, I guess these ones just sitting and waiting. Next up is 1086 harmonized max CLTB expiry across implementations. Has anyone taken a look at this one? I haven't had a chance yet.

Speaker 1: 00:07:30

No, I don't mind harmonizing. I don't think it's critical.

Speaker 2: 00:07:36

Yeah, I'm not sure why. I think this basically came from a miscommunication. I was complaining that we don't know the maximum... No, I was complaining something else about like not knowing the maximum I think CLT delta that nodes are willing to route through basically like how high can we set it before there's an issue and then we won't go any higher? And then we had a brief discussion about that in the arc and nothing really came of it. But then Antoine ran a hand and also added this for the, like, far away section, which is also related but not super related. But yeah, in general, it would be nice to have some of these be a little more, whether they're actually harmonized or at least just there's somewhere we can look that says like the values everyone uses so that we can look that up and make decisions based on that would be very nice. Cause right now it's kind of hard to make a decision for like various parameter defaults because you don't know what other people will or will not accept.

Speaker 1: 00:08:49

Yeah, I mean, my assumption was always like everyone's implementation and practice will be so far away that unless you're doing something really stupid, you're not gonna hit them. You shouldn't put it, I don't know, if you're playing on this edge, you're probably doing something wrong.

Speaker 2: 00:09:06

If you

Speaker 1: 00:09:06

try to create a four-way gate, Chelsea.

Speaker 2: 00:09:08

CHELSEA JOHNSON Yeah, this one is much less than all of the other ones, mostly though, like default delta.

Speaker 1: 00:09:16

I mean, I guess my, I always love it when somebody comes up with a number and everyone just uses it because it just saves the implementers the whole pile of mental churn trying to figure out what their magic number would be, particularly when there are considerations. So I'm not even sure what it is that we use. I suspect we use two weeks TM. So four, why not? Sure, I guess more comments on the issue from people who know what their particular values are. And if people want to defend it, that's fine.

Speaker 0: 00:10:00

Yeah, and then there's two 2016, so also two weeks at the moment.

Speaker 1: 00:10:05

Yeah, I think we're the same.

Speaker 0: 00:10:07

I think in Clare it used to be a thousand, and now they've bumped it, but I could be wrong there. Yeah.

Speaker 4: 00:10:15

Should we drop a comment in the issue to call for what those parameters are? Yeah, I'll do that right now.

Speaker 0: 00:10:27

Cool. So actions for this one, drop in what you're currently using and when folks have time give a PR a look. It hasn't got any reviews so far. Cool. Uh, Val pointed out that I missed 1093 on the list, uh, cause reading is hard. So allow empty onion hash for blinded errors. Files says it's implemented in LDK. Anything else that we need to discuss here?

Speaker 1: 00:11:09

Yes, Bastien had the same comment, I think, that he wanted unset onion hash. We were talking about whether it should be a bogus. Oh, yes, this is tbests anyway. Cool. It's all zero. Sure. It turns out nobody uses this. So the idea was that you put the hash of, here's the thing I received that I'm complaining about in case there is some weird debate between, Did you send me crap or did I somehow corrupt it? But in practice, nobody ever used this field, as far as I can tell, even for debugging. So setting it to zero doesn't break any existing implementation. Nobody does anything smart with this value. And zero is very clear. If someone's hand debugging, zero is a very clear. I do not think this is the hash of the thing that I received. So I think I can just act this.

Speaker 2: 00:12:00

Done. Cool. Cool.

Speaker 0: 00:12:08

1044,

Speaker 2: 00:12:10

attributable

Speaker 0: 00:12:13

errors. Is Yoast here? Or does anyone have anything to add on this one?

Speaker 1: 00:12:21

Yeah. So attributable errors are now much more attractive than they were previously. Because they were really quite chunky before. And the question was how big. But used has a trick that we think is acceptable that is a little bit hinky, but does reduce the size down to like 1, 300 odd bytes, which makes it much fitted much, much more nicely. So It's simply now a question of everyone actually getting around and implementing it. Because I believe this is another kind of network-wide upgrade thing, where the sooner we start, the better. But I haven't put any resources to implementing it yet myself, but it now looks like a good idea, I guess is the, it was marginal before and it's moved into my happy, good category now, so I like it. Does anyone have any actual plans to implement this?

Speaker 2: 00:13:18

Maybe I used to open the old version of it as a PR and LDK quite a while back, not an actual version, but a like demo aware level code. So I guess I owe him feedback on it now and we would like to do it too, but you know, priority isn't all that stuff.

Speaker 1: 00:13:40

Yeah. I think it's not literally on fire, but it's a nice to have.

Speaker 2: 00:13:47

So Yeah,

Speaker 0: 00:13:48

it is nice to have. I think that it is, it's pretty actively under review in Allen D last I checked and slated for a release sometime. So it is happening.

Speaker 1: 00:14:00

That'll give everyone else FOMO. So that'll probably do it.

Speaker 0: 00:14:03

Yeah, yeah, see that feature bit popping up. Oh

Speaker 2: 00:14:05

no. Yeah. Mm-hmm.

Speaker 0: 00:14:08

Okay, next up, 759 Onion Messages. Rusty, anything here?

Speaker 2: 00:14:19

Can we merge this? What's it doing on any feedback or?

Speaker 1: 00:14:28

No, we have interop.

Speaker 2: 00:14:31

T best active.

Speaker 1: 00:14:33

T best is active, We've got a whole pile of fixups on it.

Speaker 5: 00:14:43

After...

Speaker 1: 00:14:47

An ACK.

Speaker 6: 00:14:50

Oh, I

Speaker 0: 00:14:51

remember what this was. It was waiting on just sanity checking the test vectors in LDK and I told Val I'd do that and then I forgot about it. So I'll chat to Val and maybe try and either manually or properly do the test vectors and then we can merge. Or we can just go ahead because we have to interrupt. I forgot about that completely.

Speaker 1: 00:15:12

Cool. Well, I'd like the test vectors. It's always good to have test vectors checked. So let's, I'll write a comment saying we agreed to merge, to merge pending, active test vectors, test vectors. So yeah, just ping me when it's done so I can hit the button, because I'd like to hit the button on this one. Actually, I really don't care.

Speaker 2: 00:15:39

But...

Speaker 4: 00:15:39

I had a quick question on it, because, like, I'm kind of new to this part of, like, this, of the spec. But I do remember a few years ago, people were concerned about DOS vectors. I just wanted to know if that resolution had been documented anywhere. I'm sure people have talked it to death at this point. So I'm not trying to re-raise it as much as just understand where the state of that discussion is.

Speaker 1: 00:16:01

Yeah. So this is a good one. I mean, it's simple. It does suggest, I believe, that you should do some rate limiting. But it sort of lays it at hand wave as to what you're going to do. And to be fair, there's a fix me in our code. We do not do rate limiting. But then it's an experimental option. So we're like, get to keep both pieces. I mean, you can just do naive rate limiting and just go, well, if you have a channel with me, you can get, you know, 10 messages a second. And if you don't, you can have two messages a second or something.

Speaker 4: 00:16:27

Got it. So at the spec level though, it's really just like, this is a problem, solve it somehow?

Speaker 1: 00:16:32

Yeah. So the idea of doing a more sophisticated one does require spec changes, where we'd actually do some kind of pushback and say, hey, this failed. Or I rate limited this, and you can basically rate limit backwards that way. You can also increase reliability using a very similar mechanism where you kind of go the last onion message you sent me failed and it turns out that Statistically if things are not too busy, you can you will end up getting the failure all the way back to the the source um, which adds some reliability because at the moment they're unreliable right you send it if somebody isn't you find out because it times out, or you've got to send multiple and things like that. So, but that is basically a level above this, but basically getting the initial mechanism in is more than sufficient. And once, you know, once we have champagne problems of like there's too many onion messages flying around then we will look at more sophisticated things. So there's like a hand wave sketch of what that would look like but it hasn't got even a spectra after yet.

Speaker 2: 00:17:31

It's also probably worth like, naive implementation should at least do the thing they do for gossip, which certainly we do, right? If you have time in your socket, you're happily, You will happily fill it up with onion messages, but if you have any like more important things to do you will have you will of course do those first. And I think the fact that the available bandwidth is probably two maybe three orders of magnitude more than what we need for gossip messaging makes the denial of service attacks actually pretty hard to pull off in any meaningful way if you just repeat your messages a few times. So I think there's an open question about like how high of a priority is it if you just do some kind of naive rate limiting using the existing code you have for gossip messages?

Speaker 1: 00:18:25

Yeah, the spec says you should do rate limiting and that's where it leaves it. So I kind of agree with Matt. We'll go with that, and we'll see. If we actually start hitting real issues with rate limiting, as in we are rate limiting to aggressively real traffic, not people trying to stream video, then we definitely have some things that we can do.

Speaker 4: 00:18:49

Cool. Thanks for educating me on that. Cool.

Speaker 2: 00:18:55

All

Speaker 0: 00:18:57

right. So test vectors and then big green button. Very exciting. Likewise, I guess, Office 798, no updates here, Just waiting on interop.

Speaker 1: 00:19:09

And Rusty to do test vectors.

Speaker 0: 00:19:11

Rusty to do test vectors.

Speaker 1: 00:19:13

Full test vectors for all the fields and stuff. I'm just gonna, matter of typing, right? But yeah,

Speaker 0: 00:19:19

1000 monkeys GPT. Yeah, that's,

Speaker 1: 00:19:22

that should be easy. Because if you've got a decode routine, you can just feed them all in and check. So that's basically right. So

Speaker 0: 00:19:30

all right, 919, dust, exposure, threshold. This one has been sitting for a very long while at the bottom of everyone's to-do list because I believe we already do this, but it just isn't written into law. So another to-do list bump, I guess, unless anyone else has anything to add here. Cool. The infinite to do list grows ever longer. Um, nine 95 simple taproot channels. Uh, not, it's not here. Anything from anyone else?

Speaker 2: 00:20:10

There's a very large discussion to happen around the nonces, but Laleh should probably be here for that.

Speaker 1: 00:20:18

Oh yeah, Zeman's idea of basically going, let's not do this at all, is something that we should discuss too. Like not using taproot for our commitment transactions.

Speaker 2: 00:20:32

Or sorry, that's what I meant, yeah.

Speaker 1: 00:20:34

Yeah, which yeah, it's a whole can of worms around that. I see the temptation, I can also see Rezpy's frustration with, but I did all this work. So yeah, you're right. That needs a broader discussion.

Speaker 0: 00:20:53

Okay,

Speaker 5: 00:20:53

I wish it had come like two or three days early.

Speaker 1: 00:20:58

Yes. Oh, yes. Yeah.

Speaker 5: 00:21:03

Well, but in the interim, what are folks doing? Because I know that I'm continuing to operate under the assumption that we are gonna end up using non-sys. However, I guess I'm able to throw that code out.

Speaker 1: 00:21:19

Yeah, look, yeah, I'm always tempted by the simplicity of just going, let's not do, or let's push it back, right? You know, we could have future feature bit where, yeah, no, we've optimized our, you know, we've optimized our commitment transactions to have a single SIG and that's cute. I'm really tempted to go, hey, this is a good place to cut the research project, right? I don't know, you're the closest to implementing it. Like, what do you think?

Speaker 5: 00:21:54

I think the...

Speaker 2: 00:21:59

I think that your Audio cut out.

Speaker 1: 00:22:02

Wow, that's tactful. I like it. Great

Speaker 2: 00:22:10

timing.

Speaker 5: 00:22:12

Let's just see the fact that it's so easily and visually.

Speaker 2: 00:22:16

Your audio cut out. We missed all of it.

Speaker 5: 00:22:18

God damn it. And I thought I had a good internet. Well, basically what I'm saying is it's not that much of an additional onus to implement, but the simplicity of getting rid of the nonsense is very appealing, especially in terms of the introspectability of the individual, the signature composition, you know?

Speaker 1: 00:22:37

Yeah.

Speaker 5: 00:22:38

I'll be easier to debug.

Speaker 7: 00:22:41

And you're storing less sensitive secret stuff, right?

Speaker 5: 00:22:44

Yeah. But here's the thing. It is very rare that I am a true neutral, but right now I see the appeals of both paths with pretty much equal value. So I would honestly generally be fine with either decision we may end up making.

Speaker 1: 00:23:06

It sounds like you're the perfect person to make the decision, to be honest.

Speaker 5: 00:23:11

Yeah, I'll sync with Lalu. I was hoping he would be in here and with Wilmer. But for the time being, now definitely not seeing a problem with continuing to just implement those nonces. It does, it's not hard. The nonces themselves. The refactor is a pain in the ass, as everybody already knows.

Speaker 1: 00:23:36

Yeah. And I mean, the issue of playing a bit fast and loose with storing nonsense and things is always, I think, the nervousness-making from a theoretical point of view. And getting rid of that's kind of appealing.

Speaker 5: 00:23:50

Yeah. Yeah, it is. I do have, on that regard, I have PR that I actually just opened an hour or so ago against simple taproot to slightly modify the just, to increase the just-in-timeness of the local nonces for channel opening. It's very marginal. It also gets rid of the images that are there and converts them to memory JS embeds So we can more easily see diagrams and update them. But this is all operating on the assumption that's Xeman's proposal is like, it's disregarding Xeman's proposal for the time being.

Speaker 1: 00:24:30

Yeah. Okay, cool. Well, yeah, I guess, yeah, go away and have a deep think about it and decide which way you advocate for us to go because I'm too far enough away to really have an informed opinion, but I can see your dilemma.

Speaker 5: 00:24:47

Good luck. I do think so far has been resulting and either spine either is great, honestly

Speaker 0: 00:25:05

Cool okay All right 1059 taproot gossip got L here. Posted a comment right before.

Speaker 6: 00:25:15

Yeah, I just posted a comment on the PR, just giving a summary of all the updates that I took away from the meeting. So just to get a A-OK from everyone before I go ahead and actually update the whole doc. Yeah, So would appreciate it if people gave it a read before the next call. Yeah.

Speaker 2: 00:25:38

One thing that I was talking to someone about at the meeting and I don't remember who, is we should take this also as an opportunity to really clearly define a lot of the stuff that's not as clearly defined like there was some conversation about the disabled bit, and whether that means My peer is gone, I can't write a payment, or whether that means I have no available liquidity on my side of the channel. And it seems some nodes use it for one thing, some nodes use it for the other, and that's really bad. That should have one definition. So it might be worth taking this also as an opportunity to be able to much more clearly define some of these things that already exist that will presumably continue to exist, but that we should all standardize on in one way or another.

Speaker 6: 00:26:27

Right, cool. Yeah, makes sense. Awesome. Sorry, one thing just while we're on this, just one point that I just want to definitely make sure everybody kind of agrees on, and I think this might depend on the nonce decision as well, so this might be void, but the whole we don't care about the script thing means we can have like a three of three new say, right. And then the verifiers just need to check, you know, output key, uh, plus node one plus no two. Awesome. Um, so that's all good and we can prepare the verify for that from the get go. But like, we also want to tell the, uh, signers in the spec how they should be creating this. And that would use nested music, which currently there's no, like spoke to Jonas Nick about this as well. And there's no current like, yes, sorry, I see.

Speaker 1: 00:27:21

Yeah, no, I spoke to Jonas too. And yeah, they're like, there be dragons. So it seems like we need half, half aggregation is the best we can do, which is also unspecked. Thank you. But they're eager to do it. And there's some example code and things. There's a PR, a bad PR. I reviewed it. Has some fix-me's, like fix the endian here. So there's a very rough PR for ZKP that does this, but it's mathematically quite a simple operation to do the half aggregation. So we could half aggregate the two signatures and that may well be the way we have to go because recursive usig is not something that's going to happen anytime soon, it seems. Was that your conclusion too?

Speaker 6: 00:28:09

So my initial conclusion was just like, we can kind of leave it a little bit open, but give a suggestion. In the meantime, we can say there's an optional Bitcoin key one, Bitcoin key two plus tweak, and then, you know, they can reconstruct and then it can be a four, four, like a flat four, four. And then, but that's optional, right? And the verifier only verifies that it's a four, four, if those things are there, otherwise they assume it's a three of three. And then the creators of the message can, you know, they can deviate from the spec when they're creating it. So they can play with half aggregation or nested using or whatever if They really want to.

Speaker 2: 00:28:52

I was not convinced. Did someone talk to like, oh, you spoke with Jonas, you mean Jonas Neck?

Speaker 1: 00:29:02

Yeah.

Speaker 2: 00:29:03

And why do we feel like we need to have this need recursive music and not be aggregatable? Like if we, if we say like, I'm okay with my counterparty deliberately picking a node ID that is the inverse of my node ID so that they can forge a signature with only the on-chain parts. Like, we don't care. You know, if we're okay with, like, that's not in our security model, I'm wondering why we can't actually just do this.

Speaker 1: 00:29:41

Above my pay grade.

Speaker 6: 00:29:44

But wouldn't like, wouldn't the like whole, you know, let the verifier kind of just verify three of three, kind of let that be a possibility. It's just not the suggestion we give to the people, to the channel peers creating the message.

Speaker 1: 00:30:01

You can certainly do two separate signatures, one with the taproot key and one with the music between the two notes, right? That would definitely work, right? That's very simple. There's no aggregation. There's two signatures. You could definitely have a variant that has one signature and you say, if it's one signature, just assume it's signed by all three because it's easy to verify. It's just, no one may be able to create that without a lot of more math math.

Speaker 2: 00:30:30

Let's have a conversation with Jonas again. Because if we just agree on a nonce, I think we can just add the keys because we don't actually care about the linearization here or the linearization. Like it might, it will have implications on the verifier, I think, maybe, because you don't add the hashes and something, something. But I think we should get on the same page there before we jump ahead. To your more direct question, I don't want to implement it. Let's just try to get on the same page. Hopefully it won't take more than a week or whatever.

Speaker 6: 00:31:13

Cool, cool, cool.

Speaker 1: 00:31:16

Okay. So, I mean, at the end of the day, what we win out of this is one less signature. So we save 64 bytes. So I'm not panicking over it.

Speaker 2: 00:31:29

Yeah, that's true. I mean, it's nice. Especially if it's like we don't even have to worry about the details, we just add them together. That'll be nice and easy. So let's follow up. I guess I will take that as an action item. I'll follow up, Jonas. Yeah.

Speaker 1: 00:31:52

Cool. Okay. So Matt's, choose which dragons we slay. Excellent.

Speaker 0: 00:32:02

Jeff, do you want to talk about SADs now?

Speaker 8: 00:32:07

Sure. This is something that Matt came to me about in New York, and I guess there was some conversation that I wasn't part of the process of Rusty. Matt, you could correct me if I'm wrong. It could be for offers in particular.

Speaker 2: 00:32:24

Yeah. We had a conversation.

Speaker 1: 00:32:28

I think I nodded. I think it was like, yes, we should do that.

Speaker 2: 00:32:32

We had, well, no, and then you suggested another variant. So there was a conversation around switching to relaying based on SCIDs for the Onion messages, so being able to select in the blinded path, being able to select the next hop in a blinded path for an onion message by SCID. And I think there was agreement to do that. And then there was a question of, well, what about specifying the introduction point by an SCID and one bit? And so then it was a question of that's complicated, but is it worth it for the size? And I asked Jeff to come up with the sizes and apparently he has an answer for us. Take it away, Jeff.

Speaker 8: 00:33:15

All right. I need to pull up what I sent to you, which I think is my Discord chat. Sorry, give me a minute. OK, yeah, so for, let's see, roughly for anything that has people on the paths, and I think I had to find those paths to have, I want to say two hops, there would be like a 33% reduction in QR code size, or at least in the factory to encoding size. So That's essentially the numbers I got.

Speaker 1: 00:33:54

Okay, that's

Speaker 8: 00:33:54

a way to wait.

Speaker 2: 00:33:56

That's pretty big. So this is you're saying.

Speaker 8: 00:34:01

Yeah, it's sending a message on

Speaker 0: 00:34:02

630

Speaker 8: 00:34:03

if you want to scroll back and disclose.

Speaker 2: 00:34:05

So size with this is switching from just the introduction node, right?

Speaker 8: 00:34:12

I know this is where all of them sorry I wasn't. This is yeah, so I use the one bit plus or eight bytes for the interaction and eight bytes for the other ones.

Speaker 2: 00:34:24

OK, do you happen to know offhand what the difference was if we just do half of that?

Speaker 8: 00:34:31

Offhand, I don't.

Speaker 2: 00:34:32

OK,

Speaker 8: 00:34:33

but there's a difference in size, like byte size is less than a third.

Speaker 2: 00:34:37

Yeah. Yeah, that's a pretty big deal.

Speaker 1: 00:34:42

Yeah. But putting them, Doing the inside stuff is trivial. The fields are already there. It's just a matter of going, yes, you can set this, and you should use it. Doing it for the introductory point, of course, is a bigger spec change. It's more than one line. It's all doable, right? Someone's got to figure out what that looks like. Where do we put that extra bit? Do we try to stash it in the, do we put it in bit 63? I don't know.

Speaker 2: 00:35:15

I mean, we can just use a byte for that.

Speaker 8: 00:35:17

But yeah, I

Speaker 2: 00:35:18

mean, it is removing a full pub key. And that's a pretty big difference in a lot of cases, especially in QR

Speaker 1: 00:35:28

code. Yeah, 24 bytes.

Speaker 2: 00:35:31

Yeah, like looking, I mean, some of these changes, and I guess Jeff can share this table that he has, but like, I mean, some of the changes are like, one blinded path or whatever, where, okay, we remove two pub keys, and then the third pub key is like, is a third of that 30% difference. Scottmcmnlick.com So that means like 10% reduction basically, I think would be the estimate.

Speaker 8: 00:36:07

Some of link.

Speaker 2: 00:36:41

Yeah. I hate it, but my vote would be It's worth it. It's more work for Rusty though, so.

Speaker 1: 00:36:49

Yeah, no, I agree. Okay, Jeff, sounds like you're on this. Do you want us to do the spec change, put up a PR that makes both changes? And...

Speaker 8: 00:37:04

Yeah, I'd have to look into the details, but it shouldn't be too bad, I imagine.

Speaker 1: 00:37:09

Yeah, I think there's a bit saying, don't use the SCID, to be honest, you can use the SCID, and then obviously the receiver side needs to look at it. If there's no, I don't think it's security. I don't think it matters what happens if there's both. Pick one.

Speaker 8: 00:37:27

So this is, are you saying that every user still support the old way to do with these?

Speaker 1: 00:37:35

Yeah, so for long lived paths, I think you generally want pubkeys over SCIDs. If you're trying to do it like a blended path, it's gonna last for a long time. SCIDs are more transitory. So there's definitely an argument to have pubkeys.

Speaker 8: 00:37:50

Yeah, I mean, I guess the ones that are less transparent are the offer ones. That's really what matters, right? Or the bug savings matters?

Speaker 1: 00:37:59

Well, it depends on how you're using offers, right? If you're using them as long, you know, if you're writing an offer on a, I guess you maybe you're not using blinded paths if you really, really care, but at least in theory, you know, the offer that you're gonna spray paint on a wall, it's going to be there for years, you may not want to use SCIDs.

Speaker 8: 00:38:30

I wasn't for the entire conversation, but yeah.

Speaker 2: 00:38:35

Cool. All right. 869, quiescence.

Speaker 7: 00:38:52

Is everyone being silent about the subject? Was there something specific we were talking about it or just that we like it and it's great or what?

Speaker 0: 00:39:10

Bastion put on the list But I can't really see any comments updates. Maybe we just wait till next week when Bastion's back.

Speaker 7: 00:39:19

Oh yeah. I think that's one of the things he's going to get working right for interop with us. It's a little, it's more complicated than it looks, but yeah. Maybe we'll talk to him next time I see him.

Speaker 0: 00:39:29

Oh, nice. So I guess Dusty to catch up with Besty in there. 863. Oh, splicing versus dynamic commitments. 863 versus 1090. Can we merge these two proposals?

Speaker 1: 00:39:52

I know there was some discussion and whiteboarding, but I wasn't at the whiteboard. So to those who were there.

Speaker 9: 00:40:04

Yeah, so after the simplified commitments discussion, folks from L&D came up and they started discussing dynamic commitments with tbest. And so as they were breaking it down, they basically came to the conclusion that the proposals are very similar. And so I think the action item there was on the LND folks to see whether if they could basically just remove the on-chain part from splicing and arrive at the same proposal. So I think we're just waiting on them to see if that works.

Speaker 1: 00:40:53

Yeah, I think that was my suggestion that basically a splice without any actual adding inputs and outputs should map pretty well onto this dynamic commitment.

Speaker 9: 00:41:03

Yeah, because they don't want to implement any of the interactive transaction

Speaker 2: 00:41:07

stuff. Yep.

Speaker 1: 00:41:12

They do, just not yet. They just don't know it yet.

Speaker 8: 00:41:16

Yeah.

Speaker 7: 00:41:20

Yeah, I feel like that works. There's some weird things like splice lock doesn't make sense anymore.

Speaker 2: 00:41:25

A little subtle things.

Speaker 9: 00:41:29

Why do you say that? What does splice Lock do?

Speaker 7: 00:41:32

It's when it's locked on chain six confirmations, obviously, if you're not

Speaker 2: 00:41:35

doing anything on chain. Oh, I see. Yeah.

Speaker 1: 00:41:37

Well, they are doing something on chain though, right? I mean, this is the case where you wanna migrate to taproot. They just don't wanna change anything else, right? If you don't need to change on chain, it's a different, like, then there's the simple update protocol, which is even simpler, where you just, on reconnect, you just say, I want to be this kind of channel, and the other side says, I wanna be this kind of channel too and you're done. But that's not the interesting case.

Speaker 7: 00:42:09

Oh, is the other one that they move the funding output over to the taproot spot?

Speaker 1: 00:42:14

That's the one they really want, right? Which makes sense. And that's basically a splice without any in or out.

Speaker 0: 00:42:21

100%,

Speaker 2: 00:42:22

yeah.

Speaker 1: 00:42:24

If you just wanna like do something like flip to anchor outputs, you don't need any of this. It's way, way simpler.

Speaker 9: 00:42:31

Okay, It seemed like they also wanted the dynamic amendment stuff to achieve that as well.

Speaker 2: 00:42:37

But if you can already do it.

Speaker 1: 00:42:39

Yeah, you don't need that. There's a proposal to do this, which is really, really simple. It is, and I've implemented it. It's really good. It just works. And we haven't pushed it because we haven't had a significant reason to upgrade, but that's worth doing now, I think, because it'd be good to flip around over to anchors.

Speaker 9: 00:42:59

Okay. And that just uses the same STFU,

Speaker 1: 00:43:02

so yeah. Actually, STFU is optional for it because what happens is it just fails if you reconnect and you've got stuff in flight, you just don't upgrade, and you both know that. So it falls out naturally. If you wanna force it to happen, then you want to SDFU and then reconnect. But statistically, that's not a problem, right? So what happens is, in practice, is you upgrade your node and then it tries to reconnect. So the reconnect is the logical point to do this. And if both nodes have upgraded to the new hotness where they both want to change the anchors or whatever it is, then at that point, they will reconnect. Nobody's doing like stuff on the fly. So the reconnection point is the logical point to do an upgrade. And yeah, it just, the upgrade fails gracefully and doesn't happen if there is stuff happening, right? So if there are not HTLCs in flight, that's okay, but literally more HTLCs being proposed. So if you've sent add HTLC or something, and then you failed in the middle of that and you reconnect, you won't do an upgrade. Cause that just, that's messy. So yeah, it's actually independent of the STFU proposal because you can just, you can work it without it.

Speaker 9: 00:44:16

Okay, cool. Yeah, I guess we'll see what they say once they're around for the next one.

Speaker 2: 00:44:29

Yeah.

Speaker 0: 00:44:31

All right. And last item on the list. This one's also been a little stale recently. 1049 clarify channel reestablish versus 1051 rework channel reestablish. Is anyone on the call been Keeping up with this. All right. It doesn't seem so.

Speaker 1: 00:45:16

GitHub says it's asking for my review. So I should do that. Right. I will do that.

Speaker 0: 00:45:21

On the to do list. Great. Yeah.

Speaker 2: 00:45:24

So

Speaker 0: 00:45:24

I guess reminded to anyone who feels like they can take a look at those two. They've been hanging around for a while. And that's it for the sort of formal agenda, what I've got on the issue. I'd just like to make a request to folks who are at the spec meeting. If you'd like to take a look at the notes and maybe amend them, if there's anything you're unhappy with, I'm going to send those out to the mailing list on Wednesday morning. It's as good as we could do. The audio recordings didn't really come through, but I made notes and Michael from Labs made notes, so we have some kind of record. Any other topics before we close out for today? 3, 2, one. Okay, I'm going to stop recording.
